<html><head><title>Libxml reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>BaH.LibXml:</b></td>
<td class=small width=1%><a href=#globals class=small>Globals</a></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#types class=small>Types</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/bah.mod/libxml.mod/libxml.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>Libxml</h1>
<a href="http://xmlsoft.org"><img src="libxml2-logo.gif" align="right" border="0"/></a>
<p>Libxml is the XML parser and toolkit developed for the Gnome project.<br>
This is the BlitzMax implementation of the libxml library.</p>
<p>XML itself is a metalanguage to design markup languages, i.e. text language where semantic and
structure are added to the content using extra "markup" information enclosed between angle brackets.
HTML is the most well-known markup language.</p>
<p>Here are some key points about libxml:
<ul>
<li>Libxml exports Push (progressive) and Pull (blocking) type parser interfaces for both XML and HTML.</li>
<li>Libxml can do DTD validation at parse time, using a parsed document instance, or with an arbitrary DTD.</li>
<li>Libxml includes complete XPath, XPointer and XInclude implementations.</li>
<li>Basic support for HTTP and FTP client allowing applications to fetch remote resources.</li>
</ul>
<h2>Guides</h2>
The following are some pages that should help you gain a better understanding of XML and how to use it with
the Libxml module. (written by Daniel Veillard and adapted for BlitzMax by Bruce Henderson)<br>
<ul>
<li><a href="guide_xml.html">XML</a></li>
<li><a href="guide_valdtd.html">Validation &amp; DTDs</a></li>
<li><a href="guide_namespaces.html">Namespaces</a></li>
</ul>
<h2>Tutorials</h2>
<p>See the <a href="tutorial.html">Libxml Tutorial</a> for an introduction to using the libxml module.<br>
And the <a href="textreader_tutorial.html">Libxml TxmlTextReader Tutorial</a> for a guide to using the TxmlTextReader API.</p>
<h2>Examples</h2>
<p>A quick example of creating an XML document from scratch : <a href="newxml_example.bmx">newxml_example.bmx</a>
</p>
<h2><a name=globals></a>Globals Summary</h2><table class=doc width=100%><tr><td colspan=2>
<a href=#xmlDoValidityCheckingDefaultValue>xmlDoValidityCheckingDefaultValue</a>
, 
<a href=#xmlGetWarningsDefaultValue>xmlGetWarningsDefaultValue</a>
, 
<a href=#xmlIndentTreeOutput>xmlIndentTreeOutput</a>
, 
<a href=#xmlLineNumbersDefaultValue>xmlLineNumbersDefaultValue</a>
, 
<a href=#xmlLoadExtDtdDefaultValue>xmlLoadExtDtdDefaultValue</a>
, 
<a href=#xmlParserDebugEntities>xmlParserDebugEntities</a>
, 
<a href=#xmlSaveNoEmptyTags>xmlSaveNoEmptyTags</a>
</td></tr>
</table>
<h2><a name=functions></a>Functions Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#xmlCleanupParser>xmlCleanupParser</a></td><td class=docright>
Cleanup function for the XML library.
</td></tr>
<tr><td class=docleft width=1%><a href=#xmlGetLastError>xmlGetLastError</a></td><td class=docright>
Get the last global error registered.
</td></tr>
<tr><td class=docleft width=1%><a href=#xmlGetPredefinedEntity>xmlGetPredefinedEntity</a></td><td class=docright>
Check whether this name is an predefined entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#xmlSetErrorFunction>xmlSetErrorFunction</a></td><td class=docright>
Sets the callback handler for errors.
</td></tr>
<tr><td class=docleft width=1%><a href=#xmlSubstituteEntitiesDefault>xmlSubstituteEntitiesDefault</a></td><td class=docright>
Set and return the previous value for default entity support.
</td></tr>
</table>
<h2><a name=types></a>Types Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#TxmlAttribute>TxmlAttribute</a></td><td class=docright>
An XML Attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlBase>TxmlBase</a></td><td class=docright>
The base Type for <a href=#TxmlDoc>TxmlDoc</a>, <a href=#TxmlNode>TxmlNode</a>, <a href=#TxmlAttribute>TxmlAttribute</a>, <a href=#TxmlEntity>TxmlEntity</a>, <a href=#TxmlDtd>TxmlDtd</a>, <a href=#TxmlDtdElement>TxmlDtdElement</a> and <a href=#TxmlDtdAttribute>TxmlDtdAttribute</a>.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlBuffer>TxmlBuffer</a></td><td class=docright>
Xml Buffer.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlCatalog>TxmlCatalog</a></td><td class=docright>
An XML Catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlDoc>TxmlDoc</a></td><td class=docright>
An XML Document.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlDtd>TxmlDtd</a></td><td class=docright>
An XML DTD.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlDtdAttribute>TxmlDtdAttribute</a></td><td class=docright>
An XML Attribute Decl.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlDtdElement>TxmlDtdElement</a></td><td class=docright>
An XML Element.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlElementContent>TxmlElementContent</a></td><td class=docright>
An XML element content tree.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlEntity>TxmlEntity</a></td><td class=docright>
An XML Entity.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlError>TxmlError</a></td><td class=docright>
An XML Error.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlLocationSet>TxmlLocationSet</a></td><td class=docright>
An XML Location Set.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlNode>TxmlNode</a></td><td class=docright>
An XML Node.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlNodeSet>TxmlNodeSet</a></td><td class=docright>
An XML Node set.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlNotation>TxmlNotation</a></td><td class=docright>
An XML Notation.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlNs>TxmlNs</a></td><td class=docright>
An XML Namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlOutputBuffer>TxmlOutputBuffer</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlTextReader>TxmlTextReader</a></td><td class=docright>
An XML Streaming Text Reader.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlURI>TxmlURI</a></td><td class=docright>
A URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlValidCtxt>TxmlValidCtxt</a></td><td class=docright>
XML validation context.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlXIncludeCtxt>TxmlXIncludeCtxt</a></td><td class=docright>
An XML XInclude context.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlXPathCompExpr>TxmlXPathCompExpr</a></td><td class=docright>
A compiled XPath expression.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlXPathContext>TxmlXPathContext</a></td><td class=docright>
An XML XPath Context.
</td></tr>
<tr><td class=docleft width=1%><a href=#TxmlXPathObject>TxmlXPathObject</a></td><td class=docright>
An XML XPath Object.
</td></tr>
</table>
<h2
 id=globalsdet>Globals
</h2>
<table class=doc width=100% cellspacing=3 id=xmlDoValidityCheckingDefaultValue>
<tr><td class=doctop colspan=2>Global xmlDoValidityCheckingDefaultValue:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, indicate that the parser should work in validating mode.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Disabled by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlGetWarningsDefaultValue>
<tr><td class=doctop colspan=2>Global xmlGetWarningsDefaultValue:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, indicate that the parser should provide warnings.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Activated by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlIndentTreeOutput>
<tr><td class=doctop colspan=2>Global xmlIndentTreeOutput:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, asking the serializer to indent the output tree by default.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Enabled by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlLineNumbersDefaultValue>
<tr><td class=doctop colspan=2>Global xmlLineNumbersDefaultValue:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, indicate that the parser should store the line number in the content field of elements in the DOM tree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Disabled by default since this may not be safe for old classes of applicaton.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlLoadExtDtdDefaultValue>
<tr><td class=doctop colspan=2>Global xmlLoadExtDtdDefaultValue:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, indicate that the parser should load DTD while not validating.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Disabled by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlParserDebugEntities>
<tr><td class=doctop colspan=2>Global xmlParserDebugEntities:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, asking the parser to print out debugging informations while handling entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Disabled by default.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlSaveNoEmptyTags>
<tr><td class=doctop colspan=2>Global xmlSaveNoEmptyTags:Int</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Global setting, asking the serializer to not output empty tags as <empty/> but <empty></empty>.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Those two forms are undistinguishable once parsed.<br>
Disabled by default.</td></tr>
</table>
<br>
<h2
 id=functionsdet>Functions
</h2>
<table class=doc width=100% cellspacing=3 id=xmlCleanupParser>
<tr><td class=doctop colspan=2>Function xmlCleanupParser()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Cleanup function for the XML library.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It tries to reclaim all parsing related global memory allocated for the library processing.
It doesn't deallocate any document related memory. Calling this function should not prevent reusing the
library but one should call <a href=#xmlCleanupParser>xmlCleanupParser</a> only when the process has finished using the library or XML
document built with it.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlGetLastError>
<tr><td class=doctop colspan=2>Function xmlGetLastError:TxmlError()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Null if no error occured ora TxmlError object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the last global error registered.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlGetPredefinedEntity>
<tr><td class=doctop colspan=2>Function xmlGetPredefinedEntity:TxmlEntity(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Null if not, otherwise the entity.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check whether this name is an predefined entity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
</ul></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlSetErrorFunction>
<tr><td class=doctop colspan=2>Function xmlSetErrorFunction(callback(data:Object, error:TxmlError), data:Object = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the callback handler for errors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The function will be called passing the optional user data and the error details.</td></tr>
<tr><td class=docleft width=1%><a href=xmlSetErrorFunction.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml


Local s:String = "<?xml version=~q1.0~q?>~n" + ..
	"<!--This is a comment--> ~n" + ..
	"<Game>~n" + ..
	"	<test>~n" + ..
	"		<Element name=#testing#>~n" + ..
	"	</test>~n" + ..
	"</Game>~n"

xmlSetErrorFunction(errorCallback)

Local xmldoc:TxmlDoc = TxmlDoc.parseDoc(s)
DebugLog "Loaded"
If xmldoc Then 
	DebugLog "XML Valid"
	Local root:TxmlNode = xmldoc.getRootElement()
	DebugLog root.getName()

	Local children:TList = root.getChildren()
	For Local node:TxmlNode = EachIn children
		DebugLog " =>" + node.getname()					
	Next
Else
	DebugLog "** Invalid XML Syntax **"
End If

DebugLog "DONE"

End

Function errorCallback(data:Object, error:TxmlError)
	DebugLog "+++++++++  Callback :-) ++++++++"
	DebugLog "message: " + error.getErrorMessage()
	DebugLog "level  : " + error.getErrorLevel()
	DebugLog "file   : " + error.getFilename()
	DebugLog "line   : " + error.getLine()
	Local s:String[] = error.getExtraText()
	If s Then
		For Local i:Int = 0 Until s.length
			DebugLog "xtra   : " + s[i]
		Next
	End If
	DebugLog "column : " + error.getColumn()
	Local node:TxmlNode = error.getErrorNode()
	If node Then
		DebugLog "node   : " + node.getName()
	End If
End Function</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=xmlSubstituteEntitiesDefault>
<tr><td class=doctop colspan=2>Function xmlSubstituteEntitiesDefault:Int(value:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The last value for 0 for no substitution, 1 for substitution.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set and return the previous value for default entity support.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Initially the parser always keep entity references instead of substituting entity values in the
output. This function has to be used to change the default parser behavior.
<p>Parameters:
<ul>
<li><b>value</b> : the value to set</li>
</ul>
</p></td></tr>
</table>
<br>
<h2
 id=typesdet>Types
</h2>
<table class=doc width=100% cellspacing=3 id=TxmlAttribute>
<tr><td class=doctop colspan=2>Type TxmlAttribute Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Attribute.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlAttribute_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getAttributeType>getAttributeType</a></td><td class=docright>
The attribute type, if validating.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNameSpace>getNameSpace</a></td><td class=docright>
Returns the associated Namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#getValue>getValue</a></td><td class=docright>
Returns the attribute value.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttributeType>
<tr><td class=doctop colspan=2>Method getAttributeType:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The attribute type.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The attribute type, if validating.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Possible attribute types are:<br>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ATTRIBUTE_CDATA</td></tr>
<tr><td>XML_ATTRIBUTE_ID</td></tr>
<tr><td>XML_ATTRIBUTE_IDREF</td></tr>
<tr><td>XML_ATTRIBUTE_IDREFS</td></tr>
<tr><td>XML_ATTRIBUTE_ENTITY</td></tr>
<tr><td>XML_ATTRIBUTE_ENTITIES</td></tr>
<tr><td>XML_ATTRIBUTE_NMTOKEN</td></tr>
<tr><td>XML_ATTRIBUTE_NMTOKENS</td></tr>
<tr><td>XML_ATTRIBUTE_ENUMERATION</td></tr>
<tr><td>XML_ATTRIBUTE_NOTATION</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNameSpace>
<tr><td class=doctop colspan=2>Method getNameSpace:TxmlNs()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The associated namespace, or Null if none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the associated Namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getValue>
<tr><td class=doctop colspan=2>Method getValue:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the attribute value.</td></tr>
<tr><td class=docleft width=1%><a href=getValue.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	' output the document to stdout
	doc.saveFile("-")

	' print first child attributes	
	For Local attribute:TxmlAttribute = EachIn TxmlNode(doc.getRootElement().getFirstChild()).getAttributeList()

		Print attribute.getName() + " : " + attribute.getValue()

	Next
End If</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlBase>
<tr><td class=doctop colspan=2>Type TxmlBase Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The base Type for <a href=#TxmlDoc>TxmlDoc</a>, <a href=#TxmlNode>TxmlNode</a>, <a href=#TxmlAttribute>TxmlAttribute</a>, <a href=#TxmlEntity>TxmlEntity</a>, <a href=#TxmlDtd>TxmlDtd</a>, <a href=#TxmlDtdElement>TxmlDtdElement</a> and <a href=#TxmlDtdAttribute>TxmlDtdAttribute</a>.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlBase_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getChildren>getChildren</a></td><td class=docright>
Returns a list of child nodes of a given node type.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDocument>getDocument</a></td><td class=docright>
Returns the document for this object.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFirstChild>getFirstChild</a></td><td class=docright>
Get the first child.
</td></tr>
<tr><td class=docleft width=1%><a href=#getLastChild>getLastChild</a></td><td class=docright>
Get the last child.
</td></tr>
<tr><td class=docleft width=1%><a href=#getLineNumber>getLineNumber</a></td><td class=docright>
Get the line number of the element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getName>getName</a></td><td class=docright>
Returns the node name.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetParent>GetParent</a></td><td class=docright>
Get the parent.
</td></tr>
<tr><td class=docleft width=1%><a href=#getType>getType</a></td><td class=docright>
Returns the type of this xml object.
</td></tr>
<tr><td class=docleft width=1%><a href=#nextSibling>nextSibling</a></td><td class=docright>
Get the next sibling node.
</td></tr>
<tr><td class=docleft width=1%><a href=#previousSibling>previousSibling</a></td><td class=docright>
Get the previous sibling node.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getChildren>
<tr><td class=doctop colspan=2>Method getChildren:TList(nodeType:Int = XML_ELEMENT_NODE)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a list of child nodes of a given node type.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>nodeType</b> : the type of node to return, or 0 for any.</li>
</ul>
See <a href=#getType>getType</a> for a list of node types.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDocument>
<tr><td class=doctop colspan=2>Method getDocument:TxmlDoc()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the document for this object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFirstChild>
<tr><td class=doctop colspan=2>Method getFirstChild:TxmlBase(nodeType:Int = XML_ELEMENT_NODE)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The first child or Null if none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first child.</td></tr>
<tr><td class=docleft width=1%><a href=getFirstChild.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file2.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	Print "First child is - " + root.getFirstChild().getName()

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getLastChild>
<tr><td class=doctop colspan=2>Method getLastChild:TxmlBase(nodeType:Int = XML_ELEMENT_NODE)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The last child or Null if none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the last child.</td></tr>
<tr><td class=docleft width=1%><a href=getLastChild.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file2.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	Print "Last child is - " + root.getLastChild().getName()

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getLineNumber>
<tr><td class=doctop colspan=2>Method getLineNumber:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The line number if successful, or -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the line number of the element.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getName>
<tr><td class=doctop colspan=2>Method getName:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the node name.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetParent>
<tr><td class=doctop colspan=2>Method GetParent:TxmlBase()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The parent to this object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the parent.</td></tr>
<tr><td class=docleft width=1%><a href=GetParent.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file1.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	Print root.getName() + " has " + root.getChildren().count() + " children...~n"
	
	For Local node:TxmlNode = EachIn root.getChildren()
		Print "  " + node.getName() + " has parent '" + node.getParent().getName() + "'"
	Next
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getType>
<tr><td class=doctop colspan=2>Method getType:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the type of this xml object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists possible types:<br>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ELEMENT_NODE</td></tr>
<tr><td>XML_ATTRIBUTE_NODE</td></tr>
<tr><td>XML_TEXT_NODE</td></tr>
<tr><td>XML_CDATA_SECTION_NODE</td></tr>
<tr><td>XML_ENTITY_REF_NODE</td></tr>
<tr><td>XML_ENTITY_NODE</td></tr>
<tr><td>XML_PI_NODE</td></tr>
<tr><td>XML_COMMENT_NODE</td></tr>
<tr><td>XML_DOCUMENT_NODE</td></tr>
<tr><td>XML_DOCUMENT_TYPE_NODE</td></tr>
<tr><td>XML_DOCUMENT_FRAG_NODE</td></tr>
<tr><td>XML_NOTATION_NODE</td></tr>
<tr><td>XML_HTML_DOCUMENT_NODE</td></tr>
<tr><td>XML_DTD_NODE</td></tr>
<tr><td>XML_ELEMENT_DECL</td></tr>
<tr><td>XML_ATTRIBUTE_DECL</td></tr>
<tr><td>XML_ENTITY_DECL</td></tr>
<tr><td>XML_NAMESPACE_DECL</td></tr>
<tr><td>XML_XINCLUDE_START</td></tr>
<tr><td>XML_XINCLUDE_END</td></tr>
<tr><td>XML_DOCB_DOCUMENT_NODE</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=nextSibling>
<tr><td class=doctop colspan=2>Method nextSibling:TxmlBase()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The next node or Null if there are none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next sibling node.</td></tr>
<tr><td class=docleft width=1%><a href=nextSibling.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("catalog.xml")

If doc Then

	Local root:TxmlNode = doc.getRootElement()

	Local cd:TxmlNode = TxmlNode(root.getFirstChild())
	
	While cd
	
		' print element node details
		If cd.getType() = XML_ELEMENT_NODE Then
			Print cd.toString()
		End If
		
		' get the next sibling
		cd = TxmlNode(cd.nextSibling())
	Wend
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=previousSibling>
<tr><td class=doctop colspan=2>Method previousSibling:TxmlBase()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The previous node or Null if there are none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the previous sibling node.</td></tr>
<tr><td class=docleft width=1%><a href=previousSibling.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("catalog.xml")

If doc Then

	Local root:TxmlNode = doc.getRootElement()

	Local cd:TxmlNode = TxmlNode(root.getLastChild())
	
	While cd
	
		' print element node details
		If cd.getType() = XML_ELEMENT_NODE Then
			Print cd.toString()
		End If
		
		' get the previous sibling
		cd = TxmlNode(cd.previousSibling())
	Wend
	
End If</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlBuffer>
<tr><td class=doctop colspan=2>Type TxmlBuffer</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Xml Buffer.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlBuffer_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getContent>getContent</a></td><td class=docright>
Extract the content of a buffer.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlBuffer_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CreateStatic>CreateStatic</a></td><td class=docright>
Routine to create an XML buffer from an immutable memory area.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getContent>
<tr><td class=doctop colspan=2>Method getContent:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Extract the content of a buffer.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateStatic>
<tr><td class=doctop colspan=2>Function CreateStatic:TxmlBuffer(mem:Byte Ptr, size:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Routine to create an XML buffer from an immutable memory area.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The area won't be modified nor copied, and is expected to be present until the end
of the buffer lifetime.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlCatalog>
<tr><td class=doctop colspan=2>Type TxmlCatalog</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Catalog.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlCatalog_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#add>add</a></td><td class=docright>
Add an entry in the catalog, it may overwrite existing but different entries.
</td></tr>
<tr><td class=docleft width=1%><a href=#convertSGML>convertSGML</a></td><td class=docright>
Convert all the SGML catalog entries as XML ones.
</td></tr>
<tr><td class=docleft width=1%><a href=#dump>dump</a></td><td class=docright>
Dump the catalog to the given file.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the memory allocated to a Catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#isEmpty>isEmpty</a></td><td class=docright>
Check is a catalog is empty.
</td></tr>
<tr><td class=docleft width=1%><a href=#remove>remove</a></td><td class=docright>
Remove an entry from the catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#resolve>resolve</a></td><td class=docright>
Do a complete resolution lookup of an External Identifier.
</td></tr>
<tr><td class=docleft width=1%><a href=#resolvePublic>resolvePublic</a></td><td class=docright>
Try to lookup the catalog local reference associated to a public ID in that catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#resolveSystem>resolveSystem</a></td><td class=docright>
Try to lookup the catalog resource for a system ID.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlCatalog_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#addDefault>addDefault</a></td><td class=docright>
Add an entry in the catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#convertDefault>convertDefault</a></td><td class=docright>
Convert all the SGML catalog entries as XML ones.
</td></tr>
<tr><td class=docleft width=1%><a href=#defaultRemove>defaultRemove</a></td><td class=docright>
Remove an entry from the catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#defaultResolve>defaultResolve</a></td><td class=docright>
Do a complete resolution lookup of an External Identifier.
</td></tr>
<tr><td class=docleft width=1%><a href=#defaultResolvePublic>defaultResolvePublic</a></td><td class=docright>
Try to lookup the catalog reference associated to a public ID.
</td></tr>
<tr><td class=docleft width=1%><a href=#defaultResolveSystem>defaultResolveSystem</a></td><td class=docright>
Try to lookup the catalog resource for a system ID.
</td></tr>
<tr><td class=docleft width=1%><a href=#defaultResolveURI>defaultResolveURI</a></td><td class=docright>
Do a complete resolution lookup of an URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDefaults>getDefaults</a></td><td class=docright>
Used to get the user preference w.r.t. to what catalogs should be accepted.
</td></tr>
<tr><td class=docleft width=1%><a href=#loadCatalog>loadCatalog</a></td><td class=docright>
Load the catalog and build the associated data structures.
</td></tr>
<tr><td class=docleft width=1%><a href=#loadDefaultCatalg>loadDefaultCatalg</a></td><td class=docright>
Load the catalog and makes its definitions effective for the default external entity loader.
</td></tr>
<tr><td class=docleft width=1%><a href=#loadSGMLSuperCatalog>loadSGMLSuperCatalog</a></td><td class=docright>
Load an SGML super catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#newCatalog>newCatalog</a></td><td class=docright>
Create a new Catalog.
</td></tr>
<tr><td class=docleft width=1%><a href=#setDebug>setDebug</a></td><td class=docright>
Used to set the debug level for catalog operation.
</td></tr>
<tr><td class=docleft width=1%><a href=#setDefaultPrefer>setDefaultPrefer</a></td><td class=docright>
Allows to set the preference between public and system for deletion in XML Catalog resolution.
</td></tr>
<tr><td class=docleft width=1%><a href=#setDefaults>setDefaults</a></td><td class=docright>
Used to set the user preference w.r.t. to what catalogs should be accepted.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=add>
<tr><td class=doctop colspan=2>Method add:Int(rtype:String, orig:String, rep:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if successful, -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add an entry in the catalog, it may overwrite existing but different entries.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>rtype</b> : the type of record to add to the catalog</li>
<li><b>orig</b> : the system, public or prefix to match</li>
<li><b>rep</b> : the replacement value for the match</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=convertSGML>
<tr><td class=doctop colspan=2>Method convertSGML:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number of entries converted if successful, -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert all the SGML catalog entries as XML ones.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=dump>
<tr><td class=doctop colspan=2>Method dump(file:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dump the catalog to the given file.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the memory allocated to a Catalog.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isEmpty>
<tr><td class=doctop colspan=2>Method isEmpty:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if the catalog is empty, 0 if not, and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check is a catalog is empty.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=remove>
<tr><td class=doctop colspan=2>Method remove:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number of entries removed if successful, -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove an entry from the catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : the value to remove</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=resolve>
<tr><td class=doctop colspan=2>Method resolve:String(pubID:String, sysID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The URI of the resource or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a complete resolution lookup of an External Identifier.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>pubID</b> : the public ID string</li>
<li><b>sysID</b> : the system ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=resolvePublic>
<tr><td class=doctop colspan=2>Method resolvePublic:String(pubID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The local resource if found or Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to lookup the catalog local reference associated to a public ID in that catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>pubID</b> : the public ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=resolveSystem>
<tr><td class=doctop colspan=2>Method resolveSystem:String(sysID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resource if found or Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to lookup the catalog resource for a system ID.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>sysID</b> : the system ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addDefault>
<tr><td class=doctop colspan=2>Function addDefault:Int(rtype:String, orig:String, rep:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if successful, -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add an entry in the catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It may overwrite existing but different entries. If called before any other catalog routine,
allows to override the default shared catalog put in place by <a href=#initializeCatalog>initializeCatalog</a>.
<p>Parameters:
<ul>
<li><b>rtype</b> : the type of record to add to the catalog</li>
<li><b>orig</b> : the system, public or prefix to match</li>
<li><b>rep</b> : the replacement value for the match, if any</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=convertDefault>
<tr><td class=doctop colspan=2>Function convertDefault:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert all the SGML catalog entries as XML ones.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=defaultRemove>
<tr><td class=doctop colspan=2>Function defaultRemove:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number of entries removed if successful, -1 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove an entry from the catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : the value to remove</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=defaultResolve>
<tr><td class=doctop colspan=2>Function defaultResolve:String(pubID:String, sysID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The URI of the resource or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a complete resolution lookup of an External Identifier.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>pubID</b> : the public ID string</li>
<li><b>sysID</b> : the system ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=defaultResolvePublic>
<tr><td class=doctop colspan=2>Function defaultResolvePublic:String(pubID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resource if found or Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to lookup the catalog reference associated to a public ID.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>pubID</b> : the public ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=defaultResolveSystem>
<tr><td class=doctop colspan=2>Function defaultResolveSystem:String(sysID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resource if found or Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to lookup the catalog resource for a system ID.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>sysID</b> : the system ID string</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=defaultResolveURI>
<tr><td class=doctop colspan=2>Function defaultResolveURI:String(uri:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The URI of the resource or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a complete resolution lookup of an URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>uri</b> : the URI</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDefaults>
<tr><td class=doctop colspan=2>Function getDefaults:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The current xmlCatalogAllow value. See <b>setDefaults</b> for more information.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to get the user preference w.r.t. to what catalogs should be accepted.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=loadCatalog>
<tr><td class=doctop colspan=2>Function loadCatalog:TxmlCatalog(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The catalog parsed or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load the catalog and build the associated data structures.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This can be either an XML Catalog or an SGML Catalog.
It will recurse in SGML Catalog entries. On the other hand XML Catalogs are not handled recursively.
<p>Parameters:
<ul>
<li><b>filename</b> : a file path</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=loadDefaultCatalg>
<tr><td class=doctop colspan=2>Function loadDefaultCatalg:Int(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 in case of success -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load the catalog and makes its definitions effective for the default external entity loader.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It will recurse in SGML CATALOG entries.
<p>Parameters:
<ul>
<li><b>filename</b> : a file path</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=loadSGMLSuperCatalog>
<tr><td class=doctop colspan=2>Function loadSGMLSuperCatalog:TxmlCatalog(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The catalog parsed or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load an SGML super catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It won't expand CATALOG or DELEGATE references. This is only needed for manipulating SGML
Super Catalogs like adding and removing CATALOG or DELEGATE entries.
<p>Parameters:
<ul>
<li><b>filename</b> : a file path</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newCatalog>
<tr><td class=doctop colspan=2>Function newCatalog:TxmlCatalog(sgml:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new catalog or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new Catalog.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>sgml</b> : should this create an SGML catalog</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setDebug>
<tr><td class=doctop colspan=2>Function setDebug:Int(level:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The previous value of the catalog debugging level.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to set the debug level for catalog operation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>0 disable debugging, 1 enable it.
<p>Parameters:
<ul>
<li><b>level</b> : the debug level of catalogs required</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setDefaultPrefer>
<tr><td class=doctop colspan=2>Function setDefaultPrefer:Int(prefer:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The previous value of the default preference for delegation.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Allows to set the preference between public and system for deletion in XML Catalog resolution.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>(C.f. section 4.1.1 of the spec)
Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM.
<p>Parameters:
<ul>
<li><b>prefer</b> : the default preference for delegation</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setDefaults>
<tr><td class=doctop colspan=2>Function setDefaults(allow:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to set the user preference w.r.t. to what catalogs should be accepted.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists possible xmlCatalogAllow values:
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_CATA_ALLOW_NONE</td></tr>
<tr><td>XML_CATA_ALLOW_GLOBAL</td></tr>
<tr><td>XML_CATA_ALLOW_DOCUMENT</td></tr>
<tr><td>XML_CATA_ALLOW_ALL</td></tr>
</table></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlDoc>
<tr><td class=doctop colspan=2>Type TxmlDoc Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Document.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlDoc_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#addDocEntity>addDocEntity</a></td><td class=docright>
Register a new entity for this document.
</td></tr>
<tr><td class=docleft width=1%><a href=#addDtdEntity>addDtdEntity</a></td><td class=docright>
Register a new entity for this document DTD external subset.
</td></tr>
<tr><td class=docleft width=1%><a href=#addProcessingInstruction>addProcessingInstruction</a></td><td class=docright>
Creation of a processing instruction element.
</td></tr>
<tr><td class=docleft width=1%><a href=#addProperty>addProperty</a></td><td class=docright>
Create a new property carried by the document.
</td></tr>
<tr><td class=docleft width=1%><a href=#contextNormalizeAttributeValue>contextNormalizeAttributeValue</a></td><td class=docright>
Does the validation related extra step of the normalization of attribute values.
</td></tr>
<tr><td class=docleft width=1%><a href=#copy>copy</a></td><td class=docright>
Do a copy of the document info.
</td></tr>
<tr><td class=docleft width=1%><a href=#createExternalSubset>createExternalSubset</a></td><td class=docright>
Creation of a new DTD for the external subset.
</td></tr>
<tr><td class=docleft width=1%><a href=#createInternalSubset>createInternalSubset</a></td><td class=docright>
Create the internal subset of a document.
</td></tr>
<tr><td class=docleft width=1%><a href=#encodeEntities>encodeEntities</a></td><td class=docright>
Do a global encoding of a string.
</td></tr>
<tr><td class=docleft width=1%><a href=#encodeEntitiesReentrant>encodeEntitiesReentrant</a></td><td class=docright>
Do a global encoding of a string.
</td></tr>
<tr><td class=docleft width=1%><a href=#encodeSpecialChars>encodeSpecialChars</a></td><td class=docright>
Do a global encoding of a string, replacing the predefined entities.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up all the structures used by a document, tree included.
</td></tr>
<tr><td class=docleft width=1%><a href=#freeDocElementContent>freeDocElementContent</a></td><td class=docright>
Free an element content structure.
</td></tr>
<tr><td class=docleft width=1%><a href=#getCompressMode>getCompressMode</a></td><td class=docright>
Get the compression ratio for a document.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDocEntity>getDocEntity</a></td><td class=docright>
Do an entity lookup in the document entity hash table and return the corresponding entity, otherwise a lookup is done in the predefined entities too.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDtdEntity>getDtdEntity</a></td><td class=docright>
Do an entity lookup in the internal and external subsets and return the corresponding parameter entity, if found.
</td></tr>
<tr><td class=docleft width=1%><a href=#getEncoding>getEncoding</a></td><td class=docright>
The external initial encoding, if any.
</td></tr>
<tr><td class=docleft width=1%><a href=#getID>getID</a></td><td class=docright>
Search the attribute declaring the given ID.
</td></tr>
<tr><td class=docleft width=1%><a href=#getInternalSubset>getInternalSubset</a></td><td class=docright>
Get the internal subset of a document.
</td></tr>
<tr><td class=docleft width=1%><a href=#getParameterEntity>getParameterEntity</a></td><td class=docright>
Do an entity lookup in the internal and external subsets and return the corresponding parameter entity, if found.
</td></tr>
<tr><td class=docleft width=1%><a href=#getRootElement>getRootElement</a></td><td class=docright>
Returns the root element of the document.
</td></tr>
<tr><td class=docleft width=1%><a href=#getURL>getURL</a></td><td class=docright>
The document URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#getVersion>getVersion</a></td><td class=docright>
The XML version string.
</td></tr>
<tr><td class=docleft width=1%><a href=#isID>isID</a></td><td class=docright>
Determine whether an attribute is of type ID.
</td></tr>
<tr><td class=docleft width=1%><a href=#isMixedElement>isMixedElement</a></td><td class=docright>
Search in the DTDs whether an element accept Mixed content (or ANY) basically if it is supposed to accept text childs.
</td></tr>
<tr><td class=docleft width=1%><a href=#isRef>isRef</a></td><td class=docright>
Determine whether an attribute is of type Ref.
</td></tr>
<tr><td class=docleft width=1%><a href=#isStandalone>isStandalone</a></td><td class=docright>
Is this document standalone?
</td></tr>
<tr><td class=docleft width=1%><a href=#newDocElementContent>newDocElementContent</a></td><td class=docright>
Allocate an element content structure for the document.
</td></tr>
<tr><td class=docleft width=1%><a href=#newXPathContext>newXPathContext</a></td><td class=docright>
Create a new <a href=#TxmlXPathContext>TxmlXPathContext</a>.
</td></tr>
<tr><td class=docleft width=1%><a href=#normalizeAttributeValue>normalizeAttributeValue</a></td><td class=docright>
Does the validation related extra step of the normalization of attribute values.
</td></tr>
<tr><td class=docleft width=1%><a href=#removeID>removeID</a></td><td class=docright>
Remove the given attribute from the ID table maintained internally.
</td></tr>
<tr><td class=docleft width=1%><a href=#removeRef>removeRef</a></td><td class=docright>
Remove the given attribute from the Ref table maintained internally.
</td></tr>
<tr><td class=docleft width=1%><a href=#saveFile>saveFile</a></td><td class=docright>
Dump an XML document to a file.
</td></tr>
<tr><td class=docleft width=1%><a href=#saveFormatFile>saveFormatFile</a></td><td class=docright>
Dump an XML document to a file.
</td></tr>
<tr><td class=docleft width=1%><a href=#setCompressMode>setCompressMode</a></td><td class=docright>
Set the default compression mode used, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)
</td></tr>
<tr><td class=docleft width=1%><a href=#setEncoding>setEncoding</a></td><td class=docright>
Sets the document encoding.
</td></tr>
<tr><td class=docleft width=1%><a href=#setRootElement>setRootElement</a></td><td class=docright>
Set the root element of the document (doc->children is a list containing possibly comments, PIs, etc ...)
</td></tr>
<tr><td class=docleft width=1%><a href=#setStandalone>setStandalone</a></td><td class=docright>
Sets document to standalone (or not).
</td></tr>
<tr><td class=docleft width=1%><a href=#ToString>ToString</a></td><td class=docright>
Returns a string representation of the document.
</td></tr>
<tr><td class=docleft width=1%><a href=#ToStringFormat>ToStringFormat</a></td><td class=docright>
Returns a string representation of the document, optionally formatting the output.
</td></tr>
<tr><td class=docleft width=1%><a href=#XIncludeProcess>XIncludeProcess</a></td><td class=docright>
Implement the XInclude substitution on the XML document.
</td></tr>
<tr><td class=docleft width=1%><a href=#XIncludeProcessFlags>XIncludeProcessFlags</a></td><td class=docright>
Implement the XInclude substitution on the XML document.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPathOrderElements>XPathOrderElements</a></td><td class=docright>
Call this routine to speed up XPath computation on static documents.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlDoc_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#newDoc>newDoc</a></td><td class=docright>
Creates a new XML document.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseCatalogFile>parseCatalogFile</a></td><td class=docright>
Parse an XML file and build a tree.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseDoc>parseDoc</a></td><td class=docright>
Parse an XML string and build a tree.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseFile>parseFile</a></td><td class=docright>
Parse an XML file and build a tree.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addDocEntity>
<tr><td class=doctop colspan=2>Method addDocEntity:TxmlEntity(name:String, EntityType:Int, externalID:String, systemID:String, content:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The entity reference or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a new entity for this document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
<li><b>entityType</b> : the entity type (see above for details)</li>
<li><b>externalID</b> : the entity external ID, if available</li>
<li><b>systemID</b> : the entity system ID if available</li>
<li><b>content</b> : the entity content</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addDtdEntity>
<tr><td class=doctop colspan=2>Method addDtdEntity:TxmlEntity(name:String, EntityType:Int, externalID:String, systemID:String, content:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The entity reference or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a new entity for this document DTD external subset.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
<li><b>entityType</b> : the entity type (see above for details)</li>
<li><b>externalID</b> : the entity external ID, if available</li>
<li><b>systemID</b> : the entity system ID if available</li>
<li><b>content</b> : the entity content</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addProcessingInstruction>
<tr><td class=doctop colspan=2>Method addProcessingInstruction:TxmlNode(name:String, content:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new node object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a processing instruction element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note - The processing instruction is only linked against the document, not the tree structure.
You will need to additionally add it to the structure yourself.
<p>Parameters:
<ul>
<li><b>name</b> : the processing instruction name</li>
<li><b>content</b> : the processing instruction content</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addProperty>
<tr><td class=doctop colspan=2>Method addProperty:TxmlAttribute(name:String, value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new attribute object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new property carried by the document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note - The property is only linked against the document, not the tree structure.
You will need to additionally add it to the structure yourself.
<p>Parameters:
<ul>
<li><b>name</b> : the name of the attribute</li>
<li><b>value</b> : the value of the attribute</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=contextNormalizeAttributeValue>
<tr><td class=doctop colspan=2>Method contextNormalizeAttributeValue:String(elem:TxmlNode, name:String, value:String, context:TxmlValidCtxt)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new normalized string if normalization is needed, Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Does the validation related extra step of the normalization of attribute values.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the declared value is not CDATA, then the XML processor must further process
the normalized attribute value by discarding any leading and trailing space (#x20) characters,
and by replacing sequences of space (#x20) characters by single space (#x20) character.<br>
Also check VC: Standalone Document Declaration in P32, and update ctxt-&gt;valid accordingly
<p>Parameters:
<ul>
<li><b>elem</b> : the parent</li>
<li><b>name</b> : the attribute name</li>
<li><b>value</b> : the attribute value</li>
<li><b>context</b> : the validation context or Null</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=copy>
<tr><td class=doctop colspan=2>Method copy:TxmlDoc(recursive:Int = True)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a new TxmlDoc, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a copy of the document info.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>recursive</b> : if True, the content tree will be copied too as well as DTD, namespaces and entities.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=createExternalSubset>
<tr><td class=doctop colspan=2>Method createExternalSubset:TxmlDtd(name:String, externalID:String, systemID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a new TxmlDtd object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new DTD for the external subset.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>To create an internal subset, use <a href=#createInternalSubset>createInternalSubset</a>
<p>Parameters:
<ul>
<li><b>name</b> : the DTD name.</li>
<li><b>externalID</b> : the external ID.</li>
<li><b>systemID</b> : the system ID.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=createInternalSubset>
<tr><td class=doctop colspan=2>Method createInternalSubset:TxmlDtd(name:String, externalID:String, systemID:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a new TxmlDtd object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create the internal subset of a document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the DTD name.</li>
<li><b>externalID</b> : the external (PUBLIC) ID.</li>
<li><b>systemID</b> : the system ID.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=encodeEntities>
<tr><td class=doctop colspan=2>Method encodeEntities:String(text:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new string with the substitution done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a global encoding of a string.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Replaces the predefined entities and non ASCII values with their entities and CharRef counterparts.
<p>Parameters:
<ul>
<li><b>text</b> : A string to convert to XML.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=encodeEntitiesReentrant>
<tr><td class=doctop colspan=2>Method encodeEntitiesReentrant:String(inp:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A newly allocated string with the substitution done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a global encoding of a string.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Replaces the predefined entities and non ASCII values with their entities and CharRef
counterparts.
<p>Parameters:
<ul>
<li><b>inp</b> : a string to convert to XML</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=encodeSpecialChars>
<tr><td class=doctop colspan=2>Method encodeSpecialChars:String(inp:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A newly allocated string with the substitution done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a global encoding of a string, replacing the predefined entities.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>inp</b> : a string to convert to XML</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up all the structures used by a document, tree included.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=freeDocElementContent>
<tr><td class=doctop colspan=2>Method freeDocElementContent(content:TxmlElementContent)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free an element content structure.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The whole subtree is removed.
<p>Parameters:
<ul>
<li><b>content</b> : the element content tree to free</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getCompressMode>
<tr><td class=doctop colspan=2>Method getCompressMode:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 (uncompressed) to 9 (max compression)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the compression ratio for a document.</td></tr>
<tr><td class=docleft width=1%><a href=getCompressMode.bmx class=small>Example</a></td><td class=docright><pre>' XML compression
SuperStrict

Framework BaH.Libxml
Import BRL.standardio

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

Print doc.getCompressMode()

doc.setCompressMode(9)

Print doc.getCompressMode()</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDocEntity>
<tr><td class=doctop colspan=2>Method getDocEntity:TxmlEntity(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Returns the entity structure or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do an entity lookup in the document entity hash table and return the corresponding entity, otherwise a lookup is done in the predefined entities too.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDtdEntity>
<tr><td class=doctop colspan=2>Method getDtdEntity:TxmlEntity(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Returns the entity structure or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do an entity lookup in the internal and external subsets and return the corresponding parameter entity, if found.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getEncoding>
<tr><td class=doctop colspan=2>Method getEncoding:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The external initial encoding, if any.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getID>
<tr><td class=doctop colspan=2>Method getID:TxmlAttribute(id:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Null if not found, otherwise the TxmlAttrribute defining the ID.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the attribute declaring the given ID.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>id</b> : the ID value</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getInternalSubset>
<tr><td class=doctop colspan=2>Method getInternalSubset:TxmlDtd()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the DTD structure or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the internal subset of a document.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getParameterEntity>
<tr><td class=doctop colspan=2>Method getParameterEntity:TxmlEntity(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Returns the entity structure or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do an entity lookup in the internal and external subsets and return the corresponding parameter entity, if found.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the entity name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getRootElement>
<tr><td class=doctop colspan=2>Method getRootElement:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the root element of the document.</td></tr>
<tr><td class=docleft width=1%><a href=getRootElement.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("catalog.xml")

If doc Then

	' get the document root node
	Local root:TxmlNode = doc.getRootElement()

	' output the node structure
	Print root.toString()
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getURL>
<tr><td class=doctop colspan=2>Method getURL:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The document URI.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getVersion>
<tr><td class=doctop colspan=2>Method getVersion:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The XML version string.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isID>
<tr><td class=doctop colspan=2>Method isID:Int(node:TxmlNode, attr:TxmlAttribute)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 or 1 depending on the lookup result.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine whether an attribute is of type ID.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>In case we have DTD(s) then this is done if DTD loading has been requested. In the case
of HTML documents parsed with the HTML parser, then ID detection is done systematically.
<p>Parameters:
<ul>
<li><b>node</b> : the node carrying the attribute</li>
<li><b>attr</b> : the attribute</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isMixedElement>
<tr><td class=doctop colspan=2>Method isMixedElement:Int(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no, 1 if yes, and -1 if no element description is available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search in the DTDs whether an element accept Mixed content (or ANY) basically if it is supposed to accept text childs.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the element name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isRef>
<tr><td class=doctop colspan=2>Method isRef:Int(node:TxmlNode, attr:TxmlAttribute)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 or 1 depending on the lookup result.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine whether an attribute is of type Ref.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>In case we have DTD(s) then this is simple, otherwise we use an heuristic: name Ref
(upper or lowercase).
<p>Parameters:
<ul>
<li><b>node</b> : the node carrying the attribute</li>
<li><b>attr</b> : the attribute</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isStandalone>
<tr><td class=doctop colspan=2>Method isStandalone:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>True if the document has no external refs.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this document standalone?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newDocElementContent>
<tr><td class=doctop colspan=2>Method newDocElementContent:TxmlElementContent(name:String, contentType:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Null if not, otherwise the new element content structure.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Allocate an element content structure for the document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the subelement name or Null</li>
<li><b>contentType</b> : the type of element content decl (see below)</li>
</ul>
<p>The following lists the valid content types:</p>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ELEMENT_CONTENT_PCDATA</td></tr>
<tr><td>XML_ELEMENT_CONTENT_ELEMENT</td></tr>
<tr><td>XML_ELEMENT_CONTENT_SEQ</td></tr>
<tr><td>XML_ELEMENT_CONTENT_OR</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newXPathContext>
<tr><td class=doctop colspan=2>Method newXPathContext:TxmlXPathContext()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new <a href=#TxmlXPathContext>TxmlXPathContext</a>.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=normalizeAttributeValue>
<tr><td class=doctop colspan=2>Method normalizeAttributeValue:String(elem:TxmlNode, name:String, value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new normalized string if normalization is needed, Null otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Does the validation related extra step of the normalization of attribute values.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the declared value is not CDATA, then the XML processor must further process the
normalized attribute value by discarding any leading and trailing space (#x20) characters,
and by replacing sequences of space (#x20) characters by single space (#x20) character.
<p>Parameters:
<ul>
<li><b>elem</b> : the parent</li>
<li><b>name</b> : the attribute name</li>
<li><b>value</b> : the attribute value</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=removeID>
<tr><td class=doctop colspan=2>Method removeID:Int(attr:TxmlAttribute)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>-1 if the lookup failed and 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove the given attribute from the ID table maintained internally.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>attr</b> : the attribute</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=removeRef>
<tr><td class=doctop colspan=2>Method removeRef:Int(attr:TxmlAttribute)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>-1 if the lookup failed and 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove the given attribute from the Ref table maintained internally.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>attr</b> : the attribute</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=saveFile>
<tr><td class=doctop colspan=2>Method saveFile:Int(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the number of bytes written or -1 in case of failure.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dump an XML document to a file.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Will use compression if set. If <b>filename</b> is "-" the standard out (console) is used.
<p>Parameters:
<ul>
<li><b>filename</b> : the filename (or URL)</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=saveFormatFile>
<tr><td class=doctop colspan=2>Method saveFormatFile:Int(filename:String, format:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the number of bytes written or -1 in case of failure.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Dump an XML document to a file.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Will use compression if compiled in and enabled. If <b>filename</b> is "-" the standard out (console)
is used. If <b>format</b> is set to true then the document will be indented on output.
<p>Parameters:
<ul>
<li><b>filename</b> : the filename (or URL)</li>
<li><b>format</b> : should formatting spaces been added</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setCompressMode>
<tr><td class=doctop colspan=2>Method setCompressMode(mode:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the default compression mode used, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>mode</b> : the compression ratio</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=setCompressMode.bmx class=small>Example</a></td><td class=docright><pre>' XML compression
SuperStrict

Framework BaH.Libxml
Import BRL.standardio

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

Print doc.getCompressMode()

doc.setCompressMode(9)

Print doc.getCompressMode()</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setEncoding>
<tr><td class=doctop colspan=2>Method setEncoding(encoding:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the document encoding.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setRootElement>
<tr><td class=doctop colspan=2>Method setRootElement:TxmlNode(root:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the old root element if any was found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the root element of the document (doc->children is a list containing possibly comments, PIs, etc ...)</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>root</b> : the new document root element</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setStandalone>
<tr><td class=doctop colspan=2>Method setStandalone(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets document to standalone (or not).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ToString>
<tr><td class=doctop colspan=2>Method ToString:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a string representation of the document.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ToStringFormat>
<tr><td class=doctop colspan=2>Method ToStringFormat:String(format:Int = False)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a string representation of the document, optionally formatting the output.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XIncludeProcess>
<tr><td class=doctop colspan=2>Method XIncludeProcess:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no substitution were done, -1 if some processing failed or the number of substitutions done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement the XInclude substitution on the XML document.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XIncludeProcessFlags>
<tr><td class=doctop colspan=2>Method XIncludeProcessFlags:Int(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no substitution were done, -1 if some processing failed or the number of substitutions done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement the XInclude substitution on the XML document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>flags</b> : a set of xml Parser Options used for parsing XML includes (see <a href=#fromFile>fromFile</a> for option details)</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPathOrderElements>
<tr><td class=doctop colspan=2>Method XPathOrderElements:Long()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number of elements found in the document or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Call this routine to speed up XPath computation on static documents.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This stamps all the element nodes with the document order Like for line information, the order is kept
in the element->content field, the value stored is actually - the node number (starting at -1) to be able
to differentiate from line numbers.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newDoc>
<tr><td class=doctop colspan=2>Function newDoc:TxmlDoc(Version:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new XML document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>version</b> : string giving the version of XML "1.0".</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=newDoc.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

' Create a new document
Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then

	' output the document to stdout
	doc.saveFile("-")

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseCatalogFile>
<tr><td class=doctop colspan=2>Function parseCatalogFile:TxmlDoc(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resulting document tree or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an XML file and build a tree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It's like <a href=#parseFile>parseFile</a>() except it bypasses all catalog lookups. Note: Doesn't support "incbin::".
<p>Parameters:
<ul>
<li><b>filename</b> : the filename</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseDoc>
<tr><td class=doctop colspan=2>Function parseDoc:TxmlDoc(text:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resulting document tree or Null if error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an XML string and build a tree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>text</b> : the string to be parsed.</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=parseDoc.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local xml:String = "<?xml version=~q1.0~q?>"
xml:+ "<rootnode><childnode name=~qbob~q>Hello Bob!</childnode></rootnode>"

Local doc:TxmlDoc = TxmlDoc.parseDoc(xml)

If doc Then

	' output the document to stdout, with formatting
	doc.saveformatFile("-", True)

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseFile>
<tr><td class=doctop colspan=2>Function parseFile:TxmlDoc(filename:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The resulting document tree or Null if error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an XML file and build a tree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Automatic support for ZLIB/Compress compressed document is provided by default.
<p>Parameters:
<ul>
<li><b>filename</b> : the name of the file to be parsed. Supports "incbin::".</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=parseFile.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("catalog.xml")

If doc Then

	' output the document to stdout
	doc.saveFile("-")

End If</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlDtd>
<tr><td class=doctop colspan=2>Type TxmlDtd Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML DTD.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlDtd_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#copyDtd>copyDtd</a></td><td class=docright>
Do a copy of the dtd.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the DTD structure.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttrDesc>getAttrDesc</a></td><td class=docright>
Search the DTD for the description of this attribute on this element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getElementDesc>getElementDesc</a></td><td class=docright>
Search the DTD for the description of this element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getExternalID>getExternalID</a></td><td class=docright>
Returns the external identifier for PUBLIC DTD.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNotationDesc>getNotationDesc</a></td><td class=docright>
Search the DTD for the description of this notation.
</td></tr>
<tr><td class=docleft width=1%><a href=#getQAttrDesc>getQAttrDesc</a></td><td class=docright>
Search the DTD for the description of this qualified attribute on this element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getQElementDesc>getQElementDesc</a></td><td class=docright>
Search the DTD for the description of this qualified element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getSystemID>getSystemID</a></td><td class=docright>
Returns the URI for a SYSTEM or PUBLIC DTD.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=copyDtd>
<tr><td class=doctop colspan=2>Method copyDtd:TxmlDtd()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new TxmlDtd object, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a copy of the dtd.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the DTD structure.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttrDesc>
<tr><td class=doctop colspan=2>Method getAttrDesc:TxmlDtdAttribute(elem:String, name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlDtdAttribute if found or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the DTD for the description of this attribute on this element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>elem</b> : the element name</li>
<li><b>name</b> : the attribute name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getElementDesc>
<tr><td class=doctop colspan=2>Method getElementDesc:TxmlDtdElement(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlDtdElement if found or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the DTD for the description of this element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the element name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getExternalID>
<tr><td class=doctop colspan=2>Method getExternalID:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the external identifier for PUBLIC DTD.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNotationDesc>
<tr><td class=doctop colspan=2>Method getNotationDesc:TxmlNotation(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlNotation if found or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the DTD for the description of this notation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the notation name</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getQAttrDesc>
<tr><td class=doctop colspan=2>Method getQAttrDesc:TxmlDtdAttribute(elem:String, name:String, prefix:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlDtdAttribute if found or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the DTD for the description of this qualified attribute on this element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>elem</b> : the element name</li>
<li><b>name</b> : the attribute name</li>
<li><b>prefix</b> : the attribute namespace prefix</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getQElementDesc>
<tr><td class=doctop colspan=2>Method getQElementDesc:TxmlDtdElement(name:String, prefix:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlDtdElement if found or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search the DTD for the description of this qualified element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the element name</li>
<li><b>prefix</b> : the element namespace prefix</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getSystemID>
<tr><td class=doctop colspan=2>Method getSystemID:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the URI for a SYSTEM or PUBLIC DTD.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlDtdAttribute>
<tr><td class=doctop colspan=2>Type TxmlDtdAttribute Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Attribute Decl.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlDtdAttribute_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getDefaultValue>getDefaultValue</a></td><td class=docright>
Returns the attribute default value.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDefaultValue>
<tr><td class=doctop colspan=2>Method getDefaultValue:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the attribute default value.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlDtdElement>
<tr><td class=doctop colspan=2>Type TxmlDtdElement Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Element.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlDtdElement_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getElementType>getElementType</a></td><td class=docright>
Returns the element type.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPrefix>getPrefix</a></td><td class=docright>
Returns the namespace prefix, if any.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getElementType>
<tr><td class=doctop colspan=2>Method getElementType:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the element type.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists possible element types:<br>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ELEMENT_TYPE_UNDEFINED</td></tr>
<tr><td>XML_ELEMENT_TYPE_EMPTY</td></tr>
<tr><td>XML_ELEMENT_TYPE_ANY</td></tr>
<tr><td>XML_ELEMENT_TYPE_MIXED</td></tr>
<tr><td>XML_ELEMENT_TYPE_ELEMENT</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPrefix>
<tr><td class=doctop colspan=2>Method getPrefix:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the namespace prefix, if any.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlElementContent>
<tr><td class=doctop colspan=2>Type TxmlElementContent</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML element content tree.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlElementContent_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getName>getName</a></td><td class=docright>
Returns the element name.
</td></tr>
<tr><td class=docleft width=1%><a href=#getOccur>getOccur</a></td><td class=docright>
Returns the content occurance.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPrefix>getPrefix</a></td><td class=docright>
Returns the namespace prefix.
</td></tr>
<tr><td class=docleft width=1%><a href=#getType>getType</a></td><td class=docright>
Returns the content type.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getName>
<tr><td class=doctop colspan=2>Method getName:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the element name.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getOccur>
<tr><td class=doctop colspan=2>Method getOccur:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the content occurance.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists the possible content occurances:<br>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ELEMENT_CONTENT_ONCE</td></tr>
<tr><td>XML_ELEMENT_CONTENT_OPT</td></tr>
<tr><td>XML_ELEMENT_CONTENT_MULT</td></tr>
<tr><td>XML_ELEMENT_CONTENT_PLUS</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPrefix>
<tr><td class=doctop colspan=2>Method getPrefix:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the namespace prefix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getType>
<tr><td class=doctop colspan=2>Method getType:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the content type.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists the possible content types:</p>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ELEMENT_CONTENT_PCDATA</td></tr>
<tr><td>XML_ELEMENT_CONTENT_ELEMENT</td></tr>
<tr><td>XML_ELEMENT_CONTENT_SEQ</td></tr>
<tr><td>XML_ELEMENT_CONTENT_OR</td></tr>
</table></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlEntity>
<tr><td class=doctop colspan=2>Type TxmlEntity Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Entity.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlError>
<tr><td class=doctop colspan=2>Type TxmlError</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Error.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlError_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getColumn>getColumn</a></td><td class=docright>
Returns the column number of the error or 0 if not available.
</td></tr>
<tr><td class=docleft width=1%><a href=#getErrorCode>getErrorCode</a></td><td class=docright>
Returns the error code.
</td></tr>
<tr><td class=docleft width=1%><a href=#getErrorDomain>getErrorDomain</a></td><td class=docright>
Returns the part of the library that raised the error.
</td></tr>
<tr><td class=docleft width=1%><a href=#getErrorLevel>getErrorLevel</a></td><td class=docright>
Returns the error level.
</td></tr>
<tr><td class=docleft width=1%><a href=#getErrorMessage>getErrorMessage</a></td><td class=docright>
Returns the error message text.
</td></tr>
<tr><td class=docleft width=1%><a href=#getErrorNode>getErrorNode</a></td><td class=docright>
Returns the node in the tree, if available.
</td></tr>
<tr><td class=docleft width=1%><a href=#getExtraText>getExtraText</a></td><td class=docright>
Returns extra error text information, if available.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFilename>getFilename</a></td><td class=docright>
Returns the filename.
</td></tr>
<tr><td class=docleft width=1%><a href=#getLine>getLine</a></td><td class=docright>
Returns the error line, if available.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getColumn>
<tr><td class=doctop colspan=2>Method getColumn:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the column number of the error or 0 if not available.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getErrorCode>
<tr><td class=doctop colspan=2>Method getErrorCode:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the error code.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getErrorDomain>
<tr><td class=doctop colspan=2>Method getErrorDomain:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the part of the library that raised the error.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists possible domains:<br>
<table>
<tr><th>Constant</th><th>Meaning</th></tr>
<tr><td>XML_FROM_NONE</td><td>From none</td></tr>
<tr><td>XML_FROM_PARSER</td><td>The XML parser</td></tr>
<tr><td>XML_FROM_TREE</td><td>The tree module</td></tr>
<tr><td>XML_FROM_NAMESPACE</td><td>The XML Namespace module</td></tr>
<tr><td>XML_FROM_DTD</td><td>The XML DTD validation with parser contex</td></tr>
<tr><td>XML_FROM_HTML</td><td>The HTML parser</td></tr>
<tr><td>XML_FROM_MEMORY</td><td>The memory allocator</td></tr>
<tr><td>XML_FROM_OUTPUT</td><td>The serialization code</td></tr>
<tr><td>XML_FROM_IO</td><td>The Input/Output stack</td></tr>
<tr><td>XML_FROM_FTP</td><td>The FTP module</td></tr>
<tr><td>XML_FROM_HTTP</td><td>The HTTP module</td></tr>
<tr><td>XML_FROM_XINCLUDE</td><td>The XInclude processing</td></tr>
<tr><td>XML_FROM_XPATH</td><td>The XPath module</td></tr>
<tr><td>XML_FROM_XPOINTER</td><td>The XPointer module</td></tr>
<tr><td>XML_FROM_REGEXP</td><td>The regular expressions module</td></tr>
<tr><td>XML_FROM_DATATYPE</td><td>The W3C XML Schemas Datatype module</td></tr>
<tr><td>XML_FROM_SCHEMASP</td><td>The W3C XML Schemas parser module</td></tr>
<tr><td>XML_FROM_SCHEMASV</td><td>The W3C XML Schemas validation module</td></tr>
<tr><td>XML_FROM_RELAXNGP</td><td>The Relax-NG parser module</td></tr>
<tr><td>XML_FROM_RELAXNGV</td><td>The Relax-NG validator module</td></tr>
<tr><td>XML_FROM_CATALOG</td><td>The Catalog module</td></tr>
<tr><td>XML_FROM_C14N</td><td>The Canonicalization module</td></tr>
<tr><td>XML_FROM_XSLT</td><td>The XSLT engine from libxslt</td></tr>
<tr><td>XML_FROM_VALID</td><td>The XML DTD validation with valid context</td></tr>
<tr><td>XML_FROM_CHECK</td><td>The error checking module</td></tr>
<tr><td>XML_FROM_WRITER</td><td>The xmlwriter module</td></tr>
<tr><td>XML_FROM_MODULE</td><td>The dynamically loaded module</td></tr>
<tr><td>XML_FROM_I18N</td><td>The module handling character conversion</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getErrorLevel>
<tr><td class=doctop colspan=2>Method getErrorLevel:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the error level.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following is a list of error levels:<br>
<table>
<tr><th>Constant</th><th>Meaning</th></tr>
<tr><td>XML_ERR_NONE</td><td>No error</td></tr>
<tr><td>XML_ERR_WARNING</td><td>A simple warning</td></tr>
<tr><td>XML_ERR_ERROR</td><td>A recoverable error</td></tr>
<tr><td>XML_ERR_FATAL</td><td>A fatal error</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getErrorMessage>
<tr><td class=doctop colspan=2>Method getErrorMessage:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the error message text.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getErrorNode>
<tr><td class=doctop colspan=2>Method getErrorNode:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the node in the tree, if available.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getExtraText>
<tr><td class=doctop colspan=2>Method getExtraText:String[]()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns extra error text information, if available.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFilename>
<tr><td class=doctop colspan=2>Method getFilename:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the filename.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getLine>
<tr><td class=doctop colspan=2>Method getLine:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the error line, if available.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlLocationSet>
<tr><td class=doctop colspan=2>Type TxmlLocationSet</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Location Set.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlLocationSet_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#add>add</a></td><td class=docright>
Add a new TxmlXPathObject to an existing LocationSet.
</td></tr>
<tr><td class=docleft width=1%><a href=#del>del</a></td><td class=docright>
Removes a TxmlXPathObject from the LocationSet.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the LocationSet compound (not the actual ranges !).
</td></tr>
<tr><td class=docleft width=1%><a href=#merge>merge</a></td><td class=docright>
Merges two rangesets.
</td></tr>
<tr><td class=docleft width=1%><a href=#remove>remove</a></td><td class=docright>
Removes an entry from an existing LocationSet list.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlLocationSet_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Create a new xmlLocationSetPtr of type double.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=add>
<tr><td class=doctop colspan=2>Method add(value:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a new TxmlXPathObject to an existing LocationSet.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the location already exist in the set <b>value</b> is freed.
<p>Parameters:
<ul>
<li><b>value</b> : a new TxmlXPathObject</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=del>
<tr><td class=doctop colspan=2>Method del(value:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes a TxmlXPathObject from the LocationSet.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the LocationSet compound (not the actual ranges !).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=merge>
<tr><td class=doctop colspan=2>Method merge:TxmlLocationSet(value:TxmlLocationSet)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>This set once extended or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Merges two rangesets.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>All ranges from <b>value</b> are added to this set.
<p>Parameters:
<ul>
<li><b>value</b> : a location set to merge</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=remove>
<tr><td class=doctop colspan=2>Method remove(index:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes an entry from an existing LocationSet list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>index</b> : the index to remove</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Function Create:TxmlLocationSet()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new xmlLocationSetPtr of type double.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlNode>
<tr><td class=doctop colspan=2>Type TxmlNode Extends TxmlBase</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Node.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlNode_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#addAttribute>addAttribute</a></td><td class=docright>
Create a new attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#addCDataBlock>addCDataBlock</a></td><td class=docright>
Creation of a new node containing a CDATA block.
</td></tr>
<tr><td class=docleft width=1%><a href=#addChild>addChild</a></td><td class=docright>
Creation of a new child element.
</td></tr>
<tr><td class=docleft width=1%><a href=#addChildList>addChildList</a></td><td class=docright>
Add a list of nodes at the end of the child list of this node, merging adjacent TEXT nodes.
</td></tr>
<tr><td class=docleft width=1%><a href=#addComment>addComment</a></td><td class=docright>
Creation of a new node containing a comment.
</td></tr>
<tr><td class=docleft width=1%><a href=#addContent>addContent</a></td><td class=docright>
Append the extra substring to the node content.
</td></tr>
<tr><td class=docleft width=1%><a href=#addNextSibling>addNextSibling</a></td><td class=docright>
Add a new node <b>node</b> as the next sibling.
</td></tr>
<tr><td class=docleft width=1%><a href=#addPreviousSibling>addPreviousSibling</a></td><td class=docright>
Add a new node <b>node</b> as the previous sibling, merging adjacent TEXT nodes.
</td></tr>
<tr><td class=docleft width=1%><a href=#addSibling>addSibling</a></td><td class=docright>
Add a new element <b>node</b> to the list of siblings, merging adjacent TEXT nodes.
</td></tr>
<tr><td class=docleft width=1%><a href=#addTextChild>addTextChild</a></td><td class=docright>
Creation of a new child text element.
</td></tr>
<tr><td class=docleft width=1%><a href=#concatText>concatText</a></td><td class=docright>
Concat the given string at the end of the existing node content.
</td></tr>
<tr><td class=docleft width=1%><a href=#copy>copy</a></td><td class=docright>
Do a copy of the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#copyToDoc>copyToDoc</a></td><td class=docright>
Do a copy of the node to a given document.
</td></tr>
<tr><td class=docleft width=1%><a href=#freeNode>freeNode</a></td><td class=docright>
Frees a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttribute>getAttribute</a></td><td class=docright>
Search and get the value of an attribute associated to the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttributeList>getAttributeList</a></td><td class=docright>
Returns the list of node attributes.
</td></tr>
<tr><td class=docleft width=1%><a href=#getBase>getBase</a></td><td class=docright>
Searches for the BASE URL.
</td></tr>
<tr><td class=docleft width=1%><a href=#getContent>getContent</a></td><td class=docright>
Read the value of a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFirstChild>getFirstChild</a></td><td class=docright>
Get the first child.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLanguage>GetLanguage</a></td><td class=docright>
Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.
</td></tr>
<tr><td class=docleft width=1%><a href=#getLastChild>getLastChild</a></td><td class=docright>
Get the last child.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNamespace>getNamespace</a></td><td class=docright>
Returns the associated namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNodePath>getNodePath</a></td><td class=docright>
Build a structure based Path for the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNoNsAttribute>getNoNsAttribute</a></td><td class=docright>
Search and get the value of an attribute associated to the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNsAttribute>getNsAttribute</a></td><td class=docright>
Search and get the value of an attribute associated to a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#getSpacePreserve>getSpacePreserve</a></td><td class=docright>
Searches the space preserving behaviour of a node, i.e. the values of the xml:space attribute or the one carried by the nearest ancestor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetText>GetText</a></td><td class=docright>
Return the string equivalent to the text contained in the child nodes made of TEXTs and ENTITY_REFs.
</td></tr>
<tr><td class=docleft width=1%><a href=#hasAttribute>hasAttribute</a></td><td class=docright>
Search an attribute associated to the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#hasNsAttribute>hasNsAttribute</a></td><td class=docright>
Search for an attribute associated to the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#isBlankNode>isBlankNode</a></td><td class=docright>
Checks whether this node is an empty or whitespace only (and possibly ignorable) text-node.
</td></tr>
<tr><td class=docleft width=1%><a href=#isText>isText</a></td><td class=docright>
Is this node a Text node ?
</td></tr>
<tr><td class=docleft width=1%><a href=#nextNode>nextNode</a></td><td class=docright>
Get the next sibling node.
</td></tr>
<tr><td class=docleft width=1%><a href=#previousNode>previousNode</a></td><td class=docright>
Get the previous sibling node.
</td></tr>
<tr><td class=docleft width=1%><a href=#replaceNode>replaceNode</a></td><td class=docright>
Unlink the old node from its current context.
</td></tr>
<tr><td class=docleft width=1%><a href=#searchNamespace>searchNamespace</a></td><td class=docright>
Search a Namespace registered under a given name space for a document.
</td></tr>
<tr><td class=docleft width=1%><a href=#searchNsByHref>searchNsByHref</a></td><td class=docright>
Search a Namespace aliasing a given URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#setAttribute>setAttribute</a></td><td class=docright>
Set (or reset) an attribute carried by a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#setBase>setBase</a></td><td class=docright>
Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#setContent>setContent</a></td><td class=docright>
Replace the content of a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#setLanguage>setLanguage</a></td><td class=docright>
Set the language of a node, i.e. the values of the xml:lang attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#setName>setName</a></td><td class=docright>
Set (or reset) the name of a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#setNamespace>setNamespace</a></td><td class=docright>
Associate a namespace to a node, a posteriori.
</td></tr>
<tr><td class=docleft width=1%><a href=#setNsAttribute>setNsAttribute</a></td><td class=docright>
Set (or reset) an attribute carried by a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#setSpacePreserve>setSpacePreserve</a></td><td class=docright>
Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#setTreeDoc>setTreeDoc</a></td><td class=docright>
Update all nodes under the tree to point to the right document.
</td></tr>
<tr><td class=docleft width=1%><a href=#textMerge>textMerge</a></td><td class=docright>
Merge two text nodes into one.
</td></tr>
<tr><td class=docleft width=1%><a href=#toString>toString</a></td><td class=docright>
Returns a string representation of the node and its children.
</td></tr>
<tr><td class=docleft width=1%><a href=#unlinkNode>unlinkNode</a></td><td class=docright>
Unlinks a node from the document.
</td></tr>
<tr><td class=docleft width=1%><a href=#unsetAttribute>unsetAttribute</a></td><td class=docright>
Remove an attribute carried by the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#unsetNsAttribute>unsetNsAttribute</a></td><td class=docright>
Remove an attribute carried by the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#XIncludeProcessTree>XIncludeProcessTree</a></td><td class=docright>
Implement the XInclude substitution for the subtree.
</td></tr>
<tr><td class=docleft width=1%><a href=#XIncludeProcessTreeFlags>XIncludeProcessTreeFlags</a></td><td class=docright>
Implement the XInclude substitution for the subtree.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlNode_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#newNode>newNode</a></td><td class=docright>
Creation of a new node element.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addAttribute>
<tr><td class=doctop colspan=2>Method addAttribute:TxmlAttribute(name:String, value:String = "")</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The Attribute object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new attribute.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the attribute name.</li>
<li><b>value</b> : the attribute value.</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=addAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "sample.xml"
Local uri:String = "http://blitzmax.com"
Local doc:TxmlDoc

doc = parseDoc(docname, uri)
If doc <> Null Then
	doc.saveFormatFile("-", True)
	doc.free()
End If


Function parseDoc:TxmlDoc(docname:String, uri:String)

        Local doc:TxmlDoc
        Local node:TxmlNode
        Local newnode:TxmlNode
        Local newattr:TxmlAttribute

        doc = TxmlDoc.parseFile(docname)
        
        If doc = Null Then
                Print "Document not parsed successfully."
                Return Null
        End If
        
        node = doc.getRootElement()
        
        If node = Null Then
                Print "empty document"
                doc.free()
                Return Null
        End If
        
        If node.getName() <> "story" Then
                Print "document of the wrong type, root node <> story"
                doc.free()
                Return Null
        End If
        
        newnode = node.addTextChild("reference", Null, Null)
        newattr = newnode.addAttribute("uri", uri)
        Return doc
End Function</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addCDataBlock>
<tr><td class=doctop colspan=2>Method addCDataBlock:TxmlNode(content:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new node object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new node containing a CDATA block.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>content</b> : the CDATA block content</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addChild>
<tr><td class=doctop colspan=2>Method addChild:TxmlNode(name:String, namespace:TxmlNs = Null, content:String = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new child element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Added at the end of child nodes list. <b>namespace</b> and <b>content</b> parameters are optional (Null).
If <b>namespace</b> is Null, the newly created element inherits the namespace of the node. If <b>content</b> is non Null,
a child list containing the TEXTs and ENTITY_REFs node will be created.<br>
NOTE: <b>content</b> is supposed to be a piece of XML CDATA, so it allows entity references.
XML special chars must be escaped first by using doc.#encodeEntities, or #addTextChild should be used.
<p>Parameters:
<ul>
<li><b>name</b> : the name of the child.</li>
<li><b>namespace</b> : a namespace if any.</li>
<li><b>content</b> : the XML content of the child if any.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=addChild.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())

	node.addChild("ID", Null, "C0122200")

	doc.savefile("-")

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addChildList>
<tr><td class=doctop colspan=2>Method addChildList:TxmlNode(list:TList)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the last child or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a list of nodes at the end of the child list of this node, merging adjacent TEXT nodes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>list</b> : the list of nodes.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addComment>
<tr><td class=doctop colspan=2>Method addComment:TxmlNode(comment:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new node object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new node containing a comment.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>comment</b> : the comment content</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=addComment.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("catalog.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getLastChild())

	node.addComment("This CD rocks!")

	Print node.toString()

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addContent>
<tr><td class=doctop colspan=2>Method addContent(content:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Append the extra substring to the node content.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>content</b> : extra content</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=addContent.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())

	Local desc:TxmlNode = node.addChild("description", Null, Null)

	desc.addContent("Some of the songs on this CD are awesome.~n")
	desc.addContent("Tracks 5 & 6 put this CD up there...")

	doc.savefile("-")

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addNextSibling>
<tr><td class=doctop colspan=2>Method addNextSibling:TxmlNode(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new node or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a new node <b>node</b> as the next sibling.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the new node was already inserted in a document it is first unlinked from its existing context.
If the new node is ATTRIBUTE, it is added into properties 	instead of children. If there is an attribute with
equal name, it is first destroyed.
<p>Parameters:
<ul>
<li><b>node</b> : the new node.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=addNextSibling.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())

	' a new node for the document
	Local newNode:TxmlNode = TxmlNode.newnode("cd")
	newNode.addAttribute("title", "Together Alone")
	newNode.addAttribute("artist", "Crowded House")
	newNode.addChild("country", Null, "NZ")
	
	' add new node to document as sibling of node.
	node.addNextSibling(newNode)

	' output the document to stdout
	doc.saveFile("-")
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addPreviousSibling>
<tr><td class=doctop colspan=2>Method addPreviousSibling:TxmlNode(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new node or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a new node <b>node</b> as the previous sibling, merging adjacent TEXT nodes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the new node was already inserted in a document it is first unlinked from its existing context.
If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute
with equal name, it is first destroyed.
<p>Parameters:
<ul>
<li><b>node</b> : the new node.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=addPreviousSibling.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())
	
	' a new node for the document
	Local newNode:TxmlNode = TxmlNode.newnode("cd")
	newNode.addAttribute("title", "This is the Sea")
	newNode.addAttribute("artist", "Waterboys")
	newNode.addChild("country", Null, "UK")
	
	' add new node to document as previous sibling of node.
	node.addPreviousSibling(newNode)

	' output the document to stdout
	doc.saveFile("-")
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addSibling>
<tr><td class=doctop colspan=2>Method addSibling:TxmlNode(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new node or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a new element <b>node</b> to the list of siblings, merging adjacent TEXT nodes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the new element was already inserted in a document it is first unlinked from its existing context.
<p>Parameters:
<ul>
<li><b>node</b> : the new node.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=addTextChild>
<tr><td class=doctop colspan=2>Method addTextChild:TxmlNode(name:String, namespace:TxmlNs = Null, content:String = Null)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new child node.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new child text element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Added at the end of <b>parent</b> children list.
<b>namespace</b> and <b>content</b> parameters are optional (Null). If <b>namespace</b> is Null, the newly
created element inherits the namespace of the parent. If <b>content</b> is non Null, a child TEXT
node will be created containing the string <b>content</b>.<br>
NOTE: Use <a href=#addChild>addChild</a> if <b>content</b> will contain entities that need to be preserved. Use this function, <a href=#addTextChild>addTextChild</a>,
if you need to ensure that reserved XML chars that might appear in <b>content</b>, such as the ampersand,
greater-than or less-than signs, are automatically replaced by their XML escaped entity
representations.
<p>Parameters:
<ul>
<li><b>name</b> : the name of the child.</li>
<li><b>namespace</b> : a namespace, if any.</li>
<li><b>content</b> : the text content of the child, if any.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=concatText>
<tr><td class=doctop colspan=2>Method concatText:Int(content:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>-1 in case of error, 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Concat the given string at the end of the existing node content.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>content</b> : the content.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=copy>
<tr><td class=doctop colspan=2>Method copy:TxmlNode(extended:Int = 1)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a new TxmlNode, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a copy of the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>extended</b> : if 1 do a recursive copy (properties, namespaces and children when applicable)<br>
if 2 copy properties and namespaces (when applicable)</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=copyToDoc>
<tr><td class=doctop colspan=2>Method copyToDoc:TxmlNode(doc:TxmlDoc, extended:Int = 1)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a new TxmlNode, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Do a copy of the node to a given document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>doc</b> : the document.</li>
<li><b>extended</b> : if 1 do a recursive copy (properties, namespaces and children when applicable)<br>
if 2 copy properties and namespaces (when applicable)</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=freeNode>
<tr><td class=doctop colspan=2>Method freeNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Frees a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The node should be <b>unlinked</b> before being freed. See <a href=#unlinkNode>unlinkNode</a>.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttribute>
<tr><td class=doctop colspan=2>Method getAttribute:String(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The attribute value or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search and get the value of an attribute associated to the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This does the entity substitution. This function looks in DTD attribute declaration for FIXED or
default declaration values unless DTD use has been turned off.<br>
NOTE: this function acts independently of namespaces associated to the attribute. Use
<a href=#getNsAttribute>getNsAttribute</a> or <a href=#getNoNsAttribute>getNoNsAttribute</a> for namespace aware processing.
<p>Parameters:
<ul>
<li><b>name</b> : the attribute name.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=getAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "sampleuri.xml"
parseDoc(docname)

Function getReference(doc:TxmlDoc, node:TxmlNode)

	Local uri:String
	
	Local list:TList = node.getChildren()
	For node = EachIn list
		If node.getName() = "reference" Then
			uri = node.getAttribute("uri")
			Print "uri: " + uri
		End If
	Next
End Function

Function parseDoc(docname:String)

        Local doc:TxmlDoc
        Local node:TxmlNode

        doc = TxmlDoc.parseFile(docname)
        
        If doc = Null Then
                Print "Document not parsed successfully."
                Return
        End If
        
        node = doc.getRootElement()
        
        If node = Null Then
                Print "empty document"
                doc.free()
                Return
        End If
        
        If node.getName() <> "story" Then
                Print "document of the wrong type, root node <> story"
                doc.free()
                Return
        End If
        
        getReference(doc, node)
        doc.free()
End Function</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttributeList>
<tr><td class=doctop colspan=2>Method getAttributeList:TList()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The list of attributes or Null if the node has none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the list of node attributes.</td></tr>
<tr><td class=docleft width=1%><a href=getAttributeList.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file1.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	For Local node:TxmlNode = EachIn root.getChildren()
		Print node.getName() + " : "
		
		For Local attribute:TxmlAttribute = EachIn node.getAttributeList()
			Print "    " + attribute.getName() + " : " + attribute.getValue()
		Next
		
		Print ""
	Next
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getBase>
<tr><td class=doctop colspan=2>Method getBase:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The base URL, or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Searches for the BASE URL.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The code should work on both XML and HTML document even if base mechanisms are completely different.
It returns the base as defined in RFC 2396 sections 5.1.1. Base URI within Document Content and 5.1.2.
Base URI from the Encapsulating Entity However it does not return the document base (5.1.3),
use TxmlDoc. <a href=#getBase>getBase</a> for this.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getContent>
<tr><td class=doctop colspan=2>Method getContent:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The node content.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Read the value of a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This can be either the text carried directly by this node if it's a TEXT node or the aggregate
string of the values carried by this node child's (TEXT and ENTITY_REF). Entity references are substituted.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFirstChild>
<tr><td class=doctop colspan=2>Method getFirstChild:TxmlBase(nodeType:Int = XML_ELEMENT_NODE)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The first child or Null if none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first child.</td></tr>
<tr><td class=docleft width=1%><a href=getFirstChild.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file2.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	Print "First child is - " + root.getFirstChild().getName()

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLanguage>
<tr><td class=doctop colspan=2>Method GetLanguage:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the language value, or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getLastChild>
<tr><td class=doctop colspan=2>Method getLastChild:TxmlNode(nodeType:Int = XML_ELEMENT_NODE)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The last child or Null if none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the last child.</td></tr>
<tr><td class=docleft width=1%><a href=getLastChild.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "../examples/file2.xml"
Local doc:TxmlDoc

doc = TxmlDoc.parseFile(docname)
If doc Then
	Local root:TxmlNode = doc.getRootElement()
	
	Print "Last child is - " + root.getLastChild().getName()

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNamespace>
<tr><td class=doctop colspan=2>Method getNamespace:TxmlNs()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the associated namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNodePath>
<tr><td class=doctop colspan=2>Method getNodePath:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The path or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Build a structure based Path for the node.</td></tr>
<tr><td class=docleft width=1%><a href=getNodePath.bmx class=small>Example</a></td><td class=docright><pre>' output list of node paths
SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())
	
	For Local child:TxmlNode = EachIn node.getChildren()

		' output the child Xpath value
		Print child.getNodePath()
	
	Next
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNoNsAttribute>
<tr><td class=doctop colspan=2>Method getNoNsAttribute:String(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the attribute value or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search and get the value of an attribute associated to the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This does the entity substitution. This function looks in DTD attribute declaration for FIXED or
default declaration values unless DTD use has been turned off. This function is similar to <a href=#getAttribute>getAttribute</a> except
it will accept only an attribute in no namespace.
<p>Parameters:
<ul>
<li><b>name</b> : the attribute name</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNsAttribute>
<tr><td class=doctop colspan=2>Method getNsAttribute:String(name:String, namespace:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the attribute value or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search and get the value of an attribute associated to a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This attribute has to be anchored in the namespace specified. This does the entity substitution.
This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD
use has been turned off.
<p>Parameters:
<ul>
<li><b>name</b> : the attribute name</li>
<li><b>namespace</b> : the URI of the namespace</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getSpacePreserve>
<tr><td class=doctop colspan=2>Method getSpacePreserve:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Searches the space preserving behaviour of a node, i.e. the values of the xml:space attribute or the one carried by the nearest ancestor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetText>
<tr><td class=doctop colspan=2>Method GetText:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return the string equivalent to the text contained in the child nodes made of TEXTs and ENTITY_REFs.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=hasAttribute>
<tr><td class=doctop colspan=2>Method hasAttribute:TxmlAttribute(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the attribute or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search an attribute associated to the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This function also looks in DTD attribute declaration for FIXED or default declaration values
unless DTD use has been turned off.
<p>Parameters:
<ul>
<li><b>name</b> : the attribute name</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=hasAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())
	
	Local attribute:TxmlAttribute = node.hasAttribute("artist")
	
	If attribute Then
	
		Print "Artist = " + attribute.getValue()
	
	End If

End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=hasNsAttribute>
<tr><td class=doctop colspan=2>Method hasNsAttribute:TxmlAttribute(name:String, namespace:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the attribute or Null if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search for an attribute associated to the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This attribute has to be anchored in the namespace specified. This does the entity substitution.
This function looks in DTD attribute declaration for FIXED or default declaration values unless DTD
use has been turned off. Note that a namespace of Null indicates to use the default namespace.
<p>Parameters:
<ul>
<li><b>name</b> : the attribute name</li>
<li><b>namespace</b> : the URI of the namespace</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isBlankNode>
<tr><td class=doctop colspan=2>Method isBlankNode:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Checks whether this node is an empty or whitespace only (and possibly ignorable) text-node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isText>
<tr><td class=doctop colspan=2>Method isText:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this node a Text node ?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=nextNode>
<tr><td class=doctop colspan=2>Method nextNode:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The next node or Null if there are none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next sibling node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Equivalent to TxmlNode( <a href=#nextSibling>nextSibling</a>() ).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=previousNode>
<tr><td class=doctop colspan=2>Method previousNode:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The previous node or Null if there are none.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the previous sibling node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Equivalent to TxmlNode( <a href=#previousSibling>previousSibling</a>() ).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=replaceNode>
<tr><td class=doctop colspan=2>Method replaceNode:TxmlNode(withNode:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The removed node.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Unlink the old node from its current context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Prune the new one at the same place. If <b>withNode</b> was already inserted in a document it is first
unlinked from its existing context.
<p>Parameters:
<ul>
<li><b>withNode</b> : the replacing node.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=replaceNode.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.parseFile("attributes.xml")

If doc Then

	Local node:TxmlNode = TxmlNode(doc.getRootElement().getFirstChild())

	' a new node for the document
	Local newNode:TxmlNode = TxmlNode.newnode("cd")
	newNode.addAttribute("title", "High on the Happy Side")
	newNode.addAttribute("artist", "Wet Wet Wet")
	newNode.addChild("country", Null, "UK")
	
	' replace node with the new node
	node.replaceNode(newNode)

	' output the document to stdout
	doc.saveFile("-")
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=searchNamespace>
<tr><td class=doctop colspan=2>Method searchNamespace:TxmlNs(namespace:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the namespace or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search a Namespace registered under a given name space for a document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Recurse on the parents until it finds the defined namespace or return Null otherwise.
<b>nameSpace</b> can be Null, this is a search for the default namespace. We don't allow to cross entities boundaries.
If you don't declare the namespace within those you will be in troubles !!! A warning is generated to cover
this case.
<p>Parameters:
<ul>
<li><b>namespace</b> : the namespace prefix.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=searchNsByHref>
<tr><td class=doctop colspan=2>Method searchNsByHref:TxmlNs(href:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The namespace or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Search a Namespace aliasing a given URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Recurse on the parents until it finds the defined namespace or return Null otherwise.
<p>Parameters:
<ul>
<li><b>href</b> : the namespace value.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setAttribute>
<tr><td class=doctop colspan=2>Method setAttribute:TxmlAttribute(name:String, value:String = "")</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The attribute object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set (or reset) an attribute carried by a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the attribute name.</li>
<li><b>value</b> : the attribute value.</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=setAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then
	
	Local root:TxmlNode = TxmlNode.newNode("root")
	doc.setRootElement(root)
	
	' create a new empty node
	Local node:TxmlNode = root.addChild("node", Null, Null)

	Print node.toString()

	' set an attribute
	node.setAttribute("attr1", "a value")
	
	Print node.toString()
	
	' change the attribute value
	node.setAttribute("attr1", "a new value")
	
	Print node.toString()
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setBase>
<tr><td class=doctop colspan=2>Method setBase(uri:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>uri</b> : the new base URI.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setContent>
<tr><td class=doctop colspan=2>Method setContent(content:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Replace the content of a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>content</b> : the new value of the content</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=setContent.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then
	
	Local root:TxmlNode = TxmlNode.newNode("root")
	doc.setRootElement(root)
	
	' create a new empty node
	Local node:TxmlNode = root.addChild("node", Null, Null)

	Print node.toString()

	' set the node content
	node.setContent("Some text content for the node")
	
	Print node.toString()
	
	' change the node content
	node.setContent("Modified content!")
	
	Print node.toString()
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setLanguage>
<tr><td class=doctop colspan=2>Method setLanguage(lang:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the language of a node, i.e. the values of the xml:lang attribute.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>lang</b> : the language description.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setName>
<tr><td class=doctop colspan=2>Method setName(name:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set (or reset) the name of a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the new tag name</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=setName.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then
	
	Local root:TxmlNode = TxmlNode.newNode("root")
	doc.setRootElement(root)
	
	' create a new empty node
	Local node:TxmlNode = root.addChild("node", Null, Null)

	Print node.toString()

	' change the node name
	node.setName("branch")
	
	Print node.toString()
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setNamespace>
<tr><td class=doctop colspan=2>Method setNamespace(namespace:TxmlNs)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Associate a namespace to a node, a posteriori.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>namespace</b> : a namespace.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setNsAttribute>
<tr><td class=doctop colspan=2>Method setNsAttribute:TxmlAttribute(namespace:TxmlNs, name:String, value:String = "")</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The attribute object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set (or reset) an attribute carried by a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The <b>namespace</b> must be in scope, this is not checked.
<p>Parameters:
<ul>
<li><b>namespace</b> : the namespace definition.</li>
<li><b>name</b> : the attribute name.</li>
<li><b>value</b> : the attribute value.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setSpacePreserve>
<tr><td class=doctop colspan=2>Method setSpacePreserve(value:Int = False)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : the xml:space value ("0": default, 1: "preserve").</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setTreeDoc>
<tr><td class=doctop colspan=2>Method setTreeDoc(doc:TxmlDoc)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Update all nodes under the tree to point to the right document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>doc</b> : the document.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=textMerge>
<tr><td class=doctop colspan=2>Method textMerge:TxmlNode(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Merge two text nodes into one.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>node</b> : the second text node being merged.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=toString>
<tr><td class=doctop colspan=2>Method toString:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns a string representation of the node and its children.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=unlinkNode>
<tr><td class=doctop colspan=2>Method unlinkNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Unlinks a node from the document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>After unlinking, and the node is no longer required, it should be freed using <a href=#freeNode>freeNode</a>.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=unsetAttribute>
<tr><td class=doctop colspan=2>Method unsetAttribute:Int(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if successful, -1 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove an attribute carried by the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the attribute name.</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=unsetAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then
	
	Local root:TxmlNode = TxmlNode.newNode("root")
	doc.setRootElement(root)
	
	' create a new empty node
	Local node:TxmlNode = root.addChild("node", Null, Null)

	Print node.toString()

	' add some attributes
	node.setAttribute("attr1", "Attribute value")
	node.setAttribute("attr2", "Another value")
	
	Print node.toString()
	
	' remove an attribute
	node.unsetAttribute("attr1")
	
	Print node.toString()
	
End If</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=unsetNsAttribute>
<tr><td class=doctop colspan=2>Method unsetNsAttribute:Int(namespace:TxmlNs, name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if successful, -1 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Remove an attribute carried by the node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>namespace</b> : the namespace definition.</li>
<li><b>name</b> : the attribute name.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XIncludeProcessTree>
<tr><td class=doctop colspan=2>Method XIncludeProcessTree:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no substitution were done, -1 if some processing failed or the number of substitutions done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement the XInclude substitution for the subtree.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XIncludeProcessTreeFlags>
<tr><td class=doctop colspan=2>Method XIncludeProcessTreeFlags:Int(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no substitution were done, -1 if some processing failed or the number of substitutions done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement the XInclude substitution for the subtree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>flags</b> : a set of xml Parser Options used for parsing XML includes (see <a href=#fromFile>fromFile</a> for details on available options)</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newNode>
<tr><td class=doctop colspan=2>Function newNode:TxmlNode(name:String, namespace:TxmlNs = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creation of a new node element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright><b>namespace</b> is optional.
<p>Parameters:
<ul>
<li><b>name</b> : the node name.</li>
<li><b>namespace</b> : namespace, if any.</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=newNode.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml

Local doc:TxmlDoc = TxmlDoc.newDoc("1.0")

If doc Then
	
	' create a new node, initially not attached to the document
	Local root:TxmlNode = TxmlNode.newNode("root")
	
	' set the node as the document root node
	doc.setRootElement(root)
	
	' output the document to stdout
	doc.saveFile("-")
	
End If</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlNodeSet>
<tr><td class=doctop colspan=2>Type TxmlNodeSet</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Node set.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlNodeSet_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#castToBoolean>castToBoolean</a></td><td class=docright>
Converts the node set to its boolean value.
</td></tr>
<tr><td class=docleft width=1%><a href=#castToNumber>castToNumber</a></td><td class=docright>
Converts the node set to its number value.
</td></tr>
<tr><td class=docleft width=1%><a href=#castToString>castToString</a></td><td class=docright>
Converts the node set to its string value.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the node set compound (not the actual nodes !).
</td></tr>
<tr><td class=docleft width=1%><a href=#getNodeCount>getNodeCount</a></td><td class=docright>
The count of nodes in the node set.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNodeList>getNodeList</a></td><td class=docright>
The list of nodes in the node set.
</td></tr>
<tr><td class=docleft width=1%><a href=#isEmpty>isEmpty</a></td><td class=docright>
Checks whether the node set is empty or not.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToBoolean>
<tr><td class=doctop colspan=2>Method castToBoolean:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The boolean value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the node set to its boolean value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToNumber>
<tr><td class=doctop colspan=2>Method castToNumber:Double()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the node set to its number value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToString>
<tr><td class=doctop colspan=2>Method castToString:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The string value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the node set to its string value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the node set compound (not the actual nodes !).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNodeCount>
<tr><td class=doctop colspan=2>Method getNodeCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The count of nodes in the node set.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNodeList>
<tr><td class=doctop colspan=2>Method getNodeList:TList()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The list of nodes in the node set.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isEmpty>
<tr><td class=doctop colspan=2>Method isEmpty:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Checks whether the node set is empty or not.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlNotation>
<tr><td class=doctop colspan=2>Type TxmlNotation</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Notation.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlNotation_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#getName>getName</a></td><td class=docright>
Returns the notation name.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPublicID>getPublicID</a></td><td class=docright>
Returns the public identifier, if any.
</td></tr>
<tr><td class=docleft width=1%><a href=#getSystemID>getSystemID</a></td><td class=docright>
Returns the system identifier, if any.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getName>
<tr><td class=doctop colspan=2>Method getName:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the notation name.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPublicID>
<tr><td class=doctop colspan=2>Method getPublicID:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the public identifier, if any.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getSystemID>
<tr><td class=doctop colspan=2>Method getSystemID:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the system identifier, if any.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlNs>
<tr><td class=doctop colspan=2>Type TxmlNs</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Namespace.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlNs_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up the structures associated to the namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#getHref>getHref</a></td><td class=docright>
Returns the URL for the namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPrefix>getPrefix</a></td><td class=docright>
Returns the prefix for the namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#getType>getType</a></td><td class=docright>
Returns the type... global or local.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up the structures associated to the namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getHref>
<tr><td class=doctop colspan=2>Method getHref:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the URL for the namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPrefix>
<tr><td class=doctop colspan=2>Method getPrefix:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the prefix for the namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getType>
<tr><td class=doctop colspan=2>Method getType:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the type... global or local.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlOutputBuffer>
<tr><td class=doctop colspan=2>Type TxmlOutputBuffer</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlTextReader>
<tr><td class=doctop colspan=2>Type TxmlTextReader</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML Streaming Text Reader.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Text Reader API provides a simpler, more standard and more extensible interface to handle
large documents than a SAX-based reader.
<p>
A TxmlTextReader object can be instantiated through its <a href=#fromFile>fromFile</a> or <a href=#fromDoc>fromDoc</a> functions.
</p>
<p>
For more insight into this parser, see the <a href="textreader_tutorial.html">Text Reader Tutorial</a>.
</p></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlTextReader_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#attributeCount>attributeCount</a></td><td class=docright>
Provides the number of attributes of the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#baseUri>baseUri</a></td><td class=docright>
The base URI of the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#constBaseUri>constBaseUri</a></td><td class=docright>
The base URI of the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#constEncoding>constEncoding</a></td><td class=docright>
Determine the encoding of the document being read.
</td></tr>
<tr><td class=docleft width=1%><a href=#constLocalName>constLocalName</a></td><td class=docright>
The local name of the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#constName>constName</a></td><td class=docright>
The qualified name of the node, equal to Prefix :LocalName.
</td></tr>
<tr><td class=docleft width=1%><a href=#constNamespaceUri>constNamespaceUri</a></td><td class=docright>
The URI defining the namespace associated with the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#constPrefix>constPrefix</a></td><td class=docright>
A shorthand reference to the namespace associated with the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#constValue>constValue</a></td><td class=docright>
Provides the text value of the node if present.
</td></tr>
<tr><td class=docleft width=1%><a href=#constXmlLang>constXmlLang</a></td><td class=docright>
The xml:lang scope within which the node resides.
</td></tr>
<tr><td class=docleft width=1%><a href=#constXmlVersion>constXmlVersion</a></td><td class=docright>
Determine the XML version of the document being read.
</td></tr>
<tr><td class=docleft width=1%><a href=#currentDoc>currentDoc</a></td><td class=docright>
Hacking interface allowing to get the TxmlDoc correponding to the current document being accessed by the TxmlTextReader.
</td></tr>
<tr><td class=docleft width=1%><a href=#depth>depth</a></td><td class=docright>
The depth of the node in the tree.
</td></tr>
<tr><td class=docleft width=1%><a href=#expand>expand</a></td><td class=docright>
Reads the contents of the current node and the full subtree.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Deallocate all the resources associated to the reader.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttribute>getAttribute</a></td><td class=docright>
Provides the value of the attribute with the specified qualified name.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttributeByIndex>getAttributeByIndex</a></td><td class=docright>
Provides the value of the attribute with the specified index relative to the containing element.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAttributeByNamespace>getAttributeByNamespace</a></td><td class=docright>
Provides the value of the specified attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#getParserColumnNumber>getParserColumnNumber</a></td><td class=docright>
Provide the column number of the current parsing point.
</td></tr>
<tr><td class=docleft width=1%><a href=#getParserLineNumber>getParserLineNumber</a></td><td class=docright>
Provide the line number of the current parsing point.
</td></tr>
<tr><td class=docleft width=1%><a href=#getParserProperty>getParserProperty</a></td><td class=docright>
Read the parser internal property.
</td></tr>
<tr><td class=docleft width=1%><a href=#hasAttributes>hasAttributes</a></td><td class=docright>
Whether the node has attributes.
</td></tr>
<tr><td class=docleft width=1%><a href=#hasValue>hasValue</a></td><td class=docright>
Whether the node can have a text value.
</td></tr>
<tr><td class=docleft width=1%><a href=#isDefault>isDefault</a></td><td class=docright>
Whether an Attribute node was generated from the default value defined in the DTD or schema.
</td></tr>
<tr><td class=docleft width=1%><a href=#isEmptyElement>isEmptyElement</a></td><td class=docright>
Check if the current node is empty.
</td></tr>
<tr><td class=docleft width=1%><a href=#isNamespaceDecl>isNamespaceDecl</a></td><td class=docright>
Determine whether the current node is a namespace declaration rather than a regular attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#isValid>isValid</a></td><td class=docright>
Retrieve the validity status from the parser context.
</td></tr>
<tr><td class=docleft width=1%><a href=#localName>localName</a></td><td class=docright>
The local name of the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#lookupNamespace>lookupNamespace</a></td><td class=docright>
Resolves a namespace prefix in the scope of the current element.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToAttribute>moveToAttribute</a></td><td class=docright>
Moves the position of the current instance to the attribute with the specified qualified name.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToAttributeByIndex>moveToAttributeByIndex</a></td><td class=docright>
Moves the position of the current instance to the attribute with the specified index relative to the containing element.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToAttributeByNamespace>moveToAttributeByNamespace</a></td><td class=docright>
Moves the position of the current instance to the attribute with the specified local name and namespace URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToElement>moveToElement</a></td><td class=docright>
Moves the position of the current instance to the node that contains the current Attribute node.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToFirstAttribute>moveToFirstAttribute</a></td><td class=docright>
Moves the position of the current instance to the first attribute associated with the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#moveToNextAttribute>moveToNextAttribute</a></td><td class=docright>
Moves the position of the current instance to the next attribute associated with the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#name>name</a></td><td class=docright>
The qualified name of the node, equal to Prefix :LocalName.
</td></tr>
<tr><td class=docleft width=1%><a href=#namespaceUri>namespaceUri</a></td><td class=docright>
The URI defining the namespace associated with the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#nextNode>nextNode</a></td><td class=docright>
Skip to the node following the current one in document order while avoiding the subtree if any.
</td></tr>
<tr><td class=docleft width=1%><a href=#nodeType>nodeType</a></td><td class=docright>
Get the node type of the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#normalization>normalization</a></td><td class=docright>
The value indicating whether to normalize white space and attribute values.
</td></tr>
<tr><td class=docleft width=1%><a href=#prefix>prefix</a></td><td class=docright>
A shorthand reference to the namespace associated with the node.
</td></tr>
<tr><td class=docleft width=1%><a href=#preserve>preserve</a></td><td class=docright>
This tells the XML Reader to preserve the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#quoteChar>quoteChar</a></td><td class=docright>
The quotation mark character used to enclose the value of an attribute.
</td></tr>
<tr><td class=docleft width=1%><a href=#read>read</a></td><td class=docright>
Moves the position of the current instance to the next node in the stream, exposing its properties.
</td></tr>
<tr><td class=docleft width=1%><a href=#readAttributeValue>readAttributeValue</a></td><td class=docright>
Parses an attribute value into one or more Text and EntityReference nodes.
</td></tr>
<tr><td class=docleft width=1%><a href=#readInnerXml>readInnerXml</a></td><td class=docright>
Reads the contents of the current node, including child nodes and markup.
</td></tr>
<tr><td class=docleft width=1%><a href=#readOuterXml>readOuterXml</a></td><td class=docright>
Reads the contents of the current node, including child nodes and markup.
</td></tr>
<tr><td class=docleft width=1%><a href=#readState>readState</a></td><td class=docright>
Gets the read state of the reader.
</td></tr>
<tr><td class=docleft width=1%><a href=#ReadString>ReadString</a></td><td class=docright>
Reads the contents of an element or a text node as a string.
</td></tr>
<tr><td class=docleft width=1%><a href=#relaxNGValidate>relaxNGValidate</a></td><td class=docright>
Use RelaxNG to validate the document as it is processed.
</td></tr>
<tr><td class=docleft width=1%><a href=#schemaValidate>schemaValidate</a></td><td class=docright>
Use W3C XSD schema to validate the document as it is processed.
</td></tr>
<tr><td class=docleft width=1%><a href=#setParserProp>setParserProp</a></td><td class=docright>
Change the parser processing behaviour by changing some of its internal properties.
</td></tr>
<tr><td class=docleft width=1%><a href=#standalone>standalone</a></td><td class=docright>
Determine the standalone status of the document being read.
</td></tr>
<tr><td class=docleft width=1%><a href=#value>value</a></td><td class=docright>
Provides the text value of the node if present.
</td></tr>
<tr><td class=docleft width=1%><a href=#xmlLang>xmlLang</a></td><td class=docright>
The xml:lang scope within which the node resides.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlTextReader_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#fromDoc>fromDoc</a></td><td class=docright>
Create an TxmlTextReader for an XML in-memory document.
</td></tr>
<tr><td class=docleft width=1%><a href=#fromFile>fromFile</a></td><td class=docright>
Parse an XML file from the filesystem or the network.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=attributeCount>
<tr><td class=doctop colspan=2>Method attributeCount:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no attributes, -1 in case of error or the attribute count.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the number of attributes of the current node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=baseUri>
<tr><td class=doctop colspan=2>Method baseUri:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The base URI of the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constBaseUri>
<tr><td class=doctop colspan=2>Method constBaseUri:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The base URI or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The base URI of the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constEncoding>
<tr><td class=doctop colspan=2>Method constEncoding:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the encoding of the document or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine the encoding of the document being read.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constLocalName>
<tr><td class=doctop colspan=2>Method constLocalName:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The local name or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local name of the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constName>
<tr><td class=doctop colspan=2>Method constName:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The local name or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The qualified name of the node, equal to Prefix :LocalName.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constNamespaceUri>
<tr><td class=doctop colspan=2>Method constNamespaceUri:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The namespace URI or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The URI defining the namespace associated with the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constPrefix>
<tr><td class=doctop colspan=2>Method constPrefix:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The prefix or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A shorthand reference to the namespace associated with the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constValue>
<tr><td class=doctop colspan=2>Method constValue:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the string or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the text value of the node if present.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constXmlLang>
<tr><td class=doctop colspan=2>Method constXmlLang:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The xml:lang value or Null if none exists.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The xml:lang scope within which the node resides.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=constXmlVersion>
<tr><td class=doctop colspan=2>Method constXmlVersion:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the XML version of the document or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine the XML version of the document being read.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=currentDoc>
<tr><td class=doctop colspan=2>Method currentDoc:TxmlDoc()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlDoc or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Hacking interface allowing to get the TxmlDoc correponding to the current document being accessed by the TxmlTextReader.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>NOTE: as a result of this call, the reader will not destroy the associated XML document and calling free()
on the TxmlDoc is needed once the reader parsing has finished.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=depth>
<tr><td class=doctop colspan=2>Method depth:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the depth or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The depth of the node in the tree.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=expand>
<tr><td class=doctop colspan=2>Method expand:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reads the contents of the current node and the full subtree.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It then makes the subtree available until the next <a href=#read>read</a> call.
returns: A node, valid until the next <a href=#read>read</a> call or Null in case of error.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Deallocate all the resources associated to the reader.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttribute>
<tr><td class=doctop colspan=2>Method getAttribute:String(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the value of the specified attribute, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the value of the attribute with the specified qualified name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the qualified name of the attribute.</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=getAttribute.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Import BaH.Libxml

Local docname:String = "sampleuri.xml"
parseDoc(docname)

Function getReference(doc:TxmlDoc, node:TxmlNode)

	Local uri:String
	
	Local list:TList = node.getChildren()
	For node = EachIn list
		If node.getName() = "reference" Then
			uri = node.getAttribute("uri")
			Print "uri: " + uri
		End If
	Next
End Function

Function parseDoc(docname:String)

        Local doc:TxmlDoc
        Local node:TxmlNode

        doc = TxmlDoc.parseFile(docname)
        
        If doc = Null Then
                Print "Document not parsed successfully."
                Return
        End If
        
        node = doc.getRootElement()
        
        If node = Null Then
                Print "empty document"
                doc.free()
                Return
        End If
        
        If node.getName() <> "story" Then
                Print "document of the wrong type, root node <> story"
                doc.free()
                Return
        End If
        
        getReference(doc, node)
        doc.free()
End Function</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttributeByIndex>
<tr><td class=doctop colspan=2>Method getAttributeByIndex:String(index:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the value of the specified attribute, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the value of the attribute with the specified index relative to the containing element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>index</b> : the zero-based index of the attribute relative to the containing element.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAttributeByNamespace>
<tr><td class=doctop colspan=2>Method getAttributeByNamespace:String(localName:String, namespaceURI:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the value of the specified attribute, or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the value of the specified attribute.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>localName</b> : the local name of the attribute.</li>
<li><b>namespaceURI</b> : the namespace URI of the attribute.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getParserColumnNumber>
<tr><td class=doctop colspan=2>Method getParserColumnNumber:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>An int or 0 if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provide the column number of the current parsing point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getParserLineNumber>
<tr><td class=doctop colspan=2>Method getParserLineNumber:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>An int or 0 if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provide the line number of the current parsing point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getParserProperty>
<tr><td class=doctop colspan=2>Method getParserProperty:Int(prop:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The value, usually 0 or 1, or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Read the parser internal property.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The parser property can be one of the following values:
<table>
<tr><th>Constant</th></tr>
<tr><td>XXML_PARSER_LOADDTD</td></tr>
<tr><td>XXML_PARSER_DEFAULTATTRS</td></tr>
<tr><td>XXML_PARSER_VALIDATE</td></tr>
<tr><td>XXML_PARSER_SUBST_ENTITIES</td></tr>
</table>
<p>Parameters:
<ul>
<li><b>prop</b> : the parser property.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=hasAttributes>
<tr><td class=doctop colspan=2>Method hasAttributes:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if true, 0 if false, and -1 in case or error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Whether the node has attributes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=hasValue>
<tr><td class=doctop colspan=2>Method hasValue:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if true, 0 if false, and -1 in case or error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Whether the node can have a text value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isDefault>
<tr><td class=doctop colspan=2>Method isDefault:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if not defaulted, 1 if defaulted, and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Whether an Attribute node was generated from the default value defined in the DTD or schema.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isEmptyElement>
<tr><td class=doctop colspan=2>Method isEmptyElement:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if empty, 0 if not and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check if the current node is empty.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isNamespaceDecl>
<tr><td class=doctop colspan=2>Method isNamespaceDecl:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if the current node is a namespace declaration, 0 if it is a regular attribute or other type of node, or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine whether the current node is a namespace declaration rather than a regular attribute.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isValid>
<tr><td class=doctop colspan=2>Method isValid:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Retrieve the validity status from the parser context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The flag value 1 if valid, 0 if no, and -1 in case of error.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=localName>
<tr><td class=doctop colspan=2>Method localName:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the local name or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local name of the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=lookupNamespace>
<tr><td class=doctop colspan=2>Method lookupNamespace:String(prefix:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the namespace URI to which the prefix maps or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Resolves a namespace prefix in the scope of the current element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>prefix</b> : the prefix whose namespace URI is to be resolved. To return the default namespace, specify Null.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToAttribute>
<tr><td class=doctop colspan=2>Method moveToAttribute:Int(name:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the attribute with the specified qualified name.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>name</b> : the qualified name of the attribute.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToAttributeByIndex>
<tr><td class=doctop colspan=2>Method moveToAttributeByIndex:Int(index:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the attribute with the specified index relative to the containing element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>index</b> : the zero-based index of the attribute relative to the containing element.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToAttributeByNamespace>
<tr><td class=doctop colspan=2>Method moveToAttributeByNamespace:Int(localName:String, namespaceURI:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the attribute with the specified local name and namespace URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>localName</b> : the local name of the attribute.</li>
<li><b>namespaceURI</b> : the namespace URI of the attribute.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToElement>
<tr><td class=doctop colspan=2>Method moveToElement:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not moved.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the node that contains the current Attribute node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToFirstAttribute>
<tr><td class=doctop colspan=2>Method moveToFirstAttribute:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the first attribute associated with the current node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=moveToNextAttribute>
<tr><td class=doctop colspan=2>Method moveToNextAttribute:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, -1 in case of error, 0 if not found.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the next attribute associated with the current node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=name>
<tr><td class=doctop colspan=2>Method name:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the local name or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The qualified name of the node, equal to Prefix :LocalName.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=namespaceUri>
<tr><td class=doctop colspan=2>Method namespaceUri:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the namespace URI or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The URI defining the namespace associated with the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=nextNode>
<tr><td class=doctop colspan=2>Method nextNode:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if the node was read successfully, 0 if there is no more nodes to read, or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Skip to the node following the current one in document order while avoiding the subtree if any.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=nodeType>
<tr><td class=doctop colspan=2>Method nodeType:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The xmlNodeType of the current node or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the node type of the current node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=normalization>
<tr><td class=doctop colspan=2>Method normalization:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The value indicating whether to normalize white space and attribute values.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Since attribute value and end of line normalizations are a MUST in the XML specification only the value true
is accepted. The broken bahaviour of accepting out of range character entities like &amp;#0; is of course not supported
either.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=prefix>
<tr><td class=doctop colspan=2>Method prefix:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The prefix or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A shorthand reference to the namespace associated with the node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=preserve>
<tr><td class=doctop colspan=2>Method preserve:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlNode or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This tells the XML Reader to preserve the current node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The caller must also use <a href=#currentDoc>currentDoc</a> to keep an handle on the resulting document once
parsing has finished.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=quoteChar>
<tr><td class=doctop colspan=2>Method quoteChar:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>" or ' and Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The quotation mark character used to enclose the value of an attribute.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=read>
<tr><td class=doctop colspan=2>Method read:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if the node was read successfully, 0 if there is no more nodes to read, or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Moves the position of the current instance to the next node in the stream, exposing its properties.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=readAttributeValue>
<tr><td class=doctop colspan=2>Method readAttributeValue:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parses an attribute value into one or more Text and EntityReference nodes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>1 in case of success, 0 if the reader was not positioned on an attribute node or all the attribute values have been read, or -1 in case of error.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=readInnerXml>
<tr><td class=doctop colspan=2>Method readInnerXml:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the XML content, or Null if the current node is neither an element nor attribute, or has no child nodes.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reads the contents of the current node, including child nodes and markup.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=readOuterXml>
<tr><td class=doctop colspan=2>Method readOuterXml:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A string containing the XML content, or NULL if the current node is neither an element nor attribute, or has no child nodes.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reads the contents of the current node, including child nodes and markup.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=readState>
<tr><td class=doctop colspan=2>Method readState:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the read state of the reader.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The state value, or -1 in case of error.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ReadString>
<tr><td class=doctop colspan=2>Method ReadString:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Reads the contents of an element or a text node as a string.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>A string containing the contents of the Element or Text node, or Null if the reader is positioned on any other type of node.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=relaxNGValidate>
<tr><td class=doctop colspan=2>Method relaxNGValidate:Int(rng:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 in case the RelaxNG validation could be (des)activated and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Use RelaxNG to validate the document as it is processed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Activation is only possible before the first <a href=#read>read</a>. if <b>rng</b> is Null, then RelaxNG validation is desactivated.
<p>Parameters:
<ul>
<li><b>rng</b> : the path to a RelaxNG schema or Null.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=schemaValidate>
<tr><td class=doctop colspan=2>Method schemaValidate:Int(xsd:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 in case the schemas validation could be (de)activated and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Use W3C XSD schema to validate the document as it is processed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Activation is only possible before the first <a href=#read>read</a>. If <b>xsd</b> is Null, then XML Schema validation is deactivated.
<p>Parameters:
<ul>
<li><b>xsd</b> : the path to a W3C XSD schema or Null.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setParserProp>
<tr><td class=doctop colspan=2>Method setParserProp:Int(prop:Int, value:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if the call was successful, or -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Change the parser processing behaviour by changing some of its internal properties.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note that some properties can only be changed before any read has been done.
<p>Parameters:
<ul>
<li><b>prop</b> : the parser property to set. ( see <a href=#getParserProperty>getParserProperty</a> )</li>
<li><b>value</b> : usually 0 or 1 to (de)activate it.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=standalone>
<tr><td class=doctop colspan=2>Method standalone:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if the document was declared to be standalone, 0 if it was declared to be not standalone, or -1 if the document did not specify its standalone status or in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Determine the standalone status of the document being read.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=value>
<tr><td class=doctop colspan=2>Method value:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The string or Null if not available.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides the text value of the node if present.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=xmlLang>
<tr><td class=doctop colspan=2>Method xmlLang:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the xml:lang value or Null if none exists.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The xml:lang scope within which the node resides.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=fromDoc>
<tr><td class=doctop colspan=2>Function fromDoc:TxmlTextReader(text:String, url:String, encoding:String, options:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new reader or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create an TxmlTextReader for an XML in-memory document.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The parsing flags <b>options</b> are a combination of the options listed in <a href=#fromFile>fromFile</a>
<p>Parameters:
<ul>
<li><b>text</b> : the string to be parsed.</li>
<li><b>url</b> : the base URL to use for the document.</li>
<li><b>encoding</b> : the document encoding, or Null.</li>
<li><b>options</b> : a combination of xmlParserOption</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=fromFile>
<tr><td class=doctop colspan=2>Function fromFile:TxmlTextReader(filename:String, encoding:String = Null, options:Int = 0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an XML file from the filesystem or the network.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The parsing flags <b>options</b> are a combination of the following:
<table>
<tr><th>Constant</th><th>Meaning</th></tr>
<tr><td>XML_PARSE_RECOVER</td><td>recover on errors</td></tr>
<tr><td>XML_PARSE_NOENT</td><td>substitute entities</td></tr>
<tr><td>XML_PARSE_DTDLOAD</td><td>load the external subset</td></tr>
<tr><td>XML_PARSE_DTDATTR</td><td>default DTD attributes</td></tr>
<tr><td>XML_PARSE_DTDVALID</td><td>validate with the DTD</td></tr>
<tr><td>XML_PARSE_NOERROR</td><td>suppress error reports</td></tr>
<tr><td>XML_PARSE_NOWARNING</td><td>suppress warning reports</td></tr>
<tr><td>XML_PARSE_PEDANTIC</td><td>pedantic error reporting</td></tr>
<tr><td>XML_PARSE_NOBLANKS</td><td>remove blank nodes</td></tr>
<tr><td>XML_PARSE_SAX1</td><td>use the SAX1 interface internally</td></tr>
<tr><td>XML_PARSE_XINCLUDE</td><td>Implement XInclude substitition</td></tr>
<tr><td>XML_PARSE_NONET</td><td>Forbid network access</td></tr>
<tr><td>XML_PARSE_NODICT</td><td>Do not reuse the context dictionnary</td></tr>
<tr><td>XML_PARSE_NSCLEAN</td><td>remove redundant namespaces declarations</td></tr>
<tr><td>XML_PARSE_NOCDATA</td><td>merge CDATA as text nodes</td></tr>
<tr><td>XML_PARSE_NOXINCNODE</td><td>do not generate XINCLUDE START/END nodes</td></tr>
<tr><td>XML_PARSE_COMPACT</td><td>compact small text nodes</td></tr>
</table>
<p>Parameters:
<ul>
<li><b>filename</b> : a file or URL. Supports "incbin::" paths.</li>
<li><b>encoding</b> : the document encoding, or Null.</li>
<li><b>options</b> : the new reader or Null in case of error.</li>
</ul>
</p></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlURI>
<tr><td class=doctop colspan=2>Type TxmlURI</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Provides some standards-savvy functions for URI handling.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlURI_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up the TxmlURI object.
</td></tr>
<tr><td class=docleft width=1%><a href=#getAuthority>getAuthority</a></td><td class=docright>
Returns the authority part.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFragment>getFragment</a></td><td class=docright>
Returns the fragment identifier.
</td></tr>
<tr><td class=docleft width=1%><a href=#getOpaque>getOpaque</a></td><td class=docright>
Returns the opaque part.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPath>getPath</a></td><td class=docright>
Returns the path string.
</td></tr>
<tr><td class=docleft width=1%><a href=#getPort>getPort</a></td><td class=docright>
Returns the port number.
</td></tr>
<tr><td class=docleft width=1%><a href=#getQuery>getQuery</a></td><td class=docright>
Returns the query string.
</td></tr>
<tr><td class=docleft width=1%><a href=#getScheme>getScheme</a></td><td class=docright>
Returns the URI scheme.
</td></tr>
<tr><td class=docleft width=1%><a href=#getServer>getServer</a></td><td class=docright>
Returns the server part.
</td></tr>
<tr><td class=docleft width=1%><a href=#getUser>getUser</a></td><td class=docright>
Returns the user part.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseURIReference>parseURIReference</a></td><td class=docright>
Parse an URI reference string and fills in the appropriate fields of the URI structure.
</td></tr>
<tr><td class=docleft width=1%><a href=#saveURI>saveURI</a></td><td class=docright>
Save the URI as an escaped string.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlURI_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#buildURI>buildURI</a></td><td class=docright>
Computes the final URI of the reference done by checking that the given URI is valid, and building the final URI using the base URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#canonicPath>canonicPath</a></td><td class=docright>
Constructs a canonic path from the specified path.
</td></tr>
<tr><td class=docleft width=1%><a href=#createURI>createURI</a></td><td class=docright>
Simply creates an empty TxmlURI.
</td></tr>
<tr><td class=docleft width=1%><a href=#normalizeURIPath>normalizeURIPath</a></td><td class=docright>
Applies the 5 normalization steps to a path string.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseURI>parseURI</a></td><td class=docright>
Parse a URI.
</td></tr>
<tr><td class=docleft width=1%><a href=#parseURIRaw>parseURIRaw</a></td><td class=docright>
Parse an URI but allows to keep intact the original fragments.
</td></tr>
<tr><td class=docleft width=1%><a href=#URIEscape>URIEscape</a></td><td class=docright>
Escaping routine, does not do validity checks !
</td></tr>
<tr><td class=docleft width=1%><a href=#URIEscapeString>URIEscapeString</a></td><td class=docright>
This routine escapes a string to hex, ignoring reserved characters (a-z) and the characters in the exception list.
</td></tr>
<tr><td class=docleft width=1%><a href=#URIUnescapeString>URIUnescapeString</a></td><td class=docright>
Unescaping routine.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up the TxmlURI object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getAuthority>
<tr><td class=doctop colspan=2>Method getAuthority:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the authority part.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFragment>
<tr><td class=doctop colspan=2>Method getFragment:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the fragment identifier.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getOpaque>
<tr><td class=doctop colspan=2>Method getOpaque:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the opaque part.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPath>
<tr><td class=doctop colspan=2>Method getPath:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the path string.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getPort>
<tr><td class=doctop colspan=2>Method getPort:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the port number.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getQuery>
<tr><td class=doctop colspan=2>Method getQuery:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the query string.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getScheme>
<tr><td class=doctop colspan=2>Method getScheme:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the URI scheme.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getServer>
<tr><td class=doctop colspan=2>Method getServer:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the server part.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getUser>
<tr><td class=doctop colspan=2>Method getUser:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the user part.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseURIReference>
<tr><td class=doctop colspan=2>Method parseURIReference:Int(uri:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 or the error code.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an URI reference string and fills in the appropriate fields of the URI structure.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
<p>Parameters:
<ul>
<li><b>uri</b> : the string to analyze</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=saveURI>
<tr><td class=doctop colspan=2>Method saveURI:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new string.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Save the URI as an escaped string.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=buildURI>
<tr><td class=doctop colspan=2>Function buildURI:String(uri:String, base:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new URI string or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Computes the final URI of the reference done by checking that the given URI is valid, and building the final URI using the base URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This is processed according to section 5.2 of the RFC 2396 5.2. Resolving Relative References to
Absolute Form
<p>Parameters:
<ul>
<li><b>uri</b> : the URI instance found in the document</li>
<li><b>base</b> : the base value</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=canonicPath>
<tr><td class=doctop colspan=2>Function canonicPath:String(path:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new canonic path, or a duplicate of the path parameter if the construction fails.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constructs a canonic path from the specified path.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>path</b> : the resource locator in a filesystem notation</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=createURI>
<tr><td class=doctop colspan=2>Function createURI:TxmlURI()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new structure or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Simply creates an empty TxmlURI.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=normalizeURIPath>
<tr><td class=doctop colspan=2>Function normalizeURIPath:String(path:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The normalized string.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies the 5 normalization steps to a path string.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>That is, RFC 2396 Section 5.2, steps 6.c through 6.g.
<p>Parameters:
<ul>
<li><b>path</b> : the path string</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseURI>
<tr><td class=doctop colspan=2>Function parseURI:TxmlURI(uri:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A newly built TxmlURI or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse a URI.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
<p>Parameters:
<ul>
<li><b>uri</b> : the URI string to analyze</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=parseURI.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local s:String = "http://www.somesite.com:8080/stuff/index.php?count=1#second"

Local uri:TxmlURI = TxmlURI.parseURI(s)

Print "server   = " + uri.getServer()
Print "port     = " + uri.getPort()
Print "path     = " + uri.getPath()
Print "query    = " + uri.getQuery()
Print "fragment = " + uri.getFragment()</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=parseURIRaw>
<tr><td class=doctop colspan=2>Function parseURIRaw:TxmlURI(uri:String, raw:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A newly built TxmlURI or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Parse an URI but allows to keep intact the original fragments.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
<p>Parameters:
<ul>
<li><b>uri</b> : the URI string to analyze</li>
<li><b>raw</b> : if 1 unescaping of URI pieces are disabled</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=URIEscape>
<tr><td class=doctop colspan=2>Function URIEscape:String(uri:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A copy of the string, but escaped.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Escaping routine, does not do validity checks !</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It will try to escape the chars needing this, but this is heuristic based it's impossible to be sure.
<p>Parameters:
<ul>
<li><b>uri</b> : the string of the URI to escape</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=URIEscapeString>
<tr><td class=doctop colspan=2>Function URIEscapeString:String(uri:String, list:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A new escaped string or Null in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This routine escapes a string to hex, ignoring reserved characters (a-z) and the characters in the exception list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>uri</b> : the string to escape</li>
<li><b>list</b> : exception list string of chars not to escape, if any</li>
</ul></td></tr>
<tr><td class=docleft width=1%><a href=URIEscapeString.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local s:String = "a b c !$%^&*(_09<>?"

' print original string
Print s
' print escaped string
Print TxmlURI.URIEscapeString(s, Null)</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=URIUnescapeString>
<tr><td class=doctop colspan=2>Function URIUnescapeString:String(str:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A copy of the string, but unescaped.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Unescaping routine.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Does not do validity checks. Output is direct unsigned char translation of <i>XX</i> values (no encoding)
<p>Parameters:
<ul>
<li><b>str</b> : the string to unescape</li>
</ul>
</p></td></tr>
<tr><td class=docleft width=1%><a href=URIUnescapeString.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict

Framework BaH.Libxml
Import BRL.StandardIO

Local s:String = "a%20b%20c%20!%A3%24%25%5E%26*(_09%3C%3E%3F"

' print original escaped string
Print s
' print unescaped string
Print TxmlURI.URIUnescapeString(s)</pre></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlValidCtxt>
<tr><td class=doctop colspan=2>Type TxmlValidCtxt</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>XML validation context.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlValidCtxt_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#buildContentModel>buildContentModel</a></td><td class=docright>
(Re)Build the automata associated to the content model of the element.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the validation context structure.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDocument>getDocument</a></td><td class=docright>
Returns the document for this object.
</td></tr>
<tr><td class=docleft width=1%><a href=#isFinishedDtd>isFinishedDtd</a></td><td class=docright>
Returns true if finished validating the DTD.
</td></tr>
<tr><td class=docleft width=1%><a href=#isValid>isValid</a></td><td class=docright>
Returns the temporary validity check result state.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateAttributeDecl>validateAttributeDecl</a></td><td class=docright>
Try to validate a single attribute definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateDocument>validateDocument</a></td><td class=docright>
Try to validate the document instance.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateDocumentFinal>validateDocumentFinal</a></td><td class=docright>
Does the final step for the document validation once all the incremental validation steps have been completed.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateDtd>validateDtd</a></td><td class=docright>
Try to validate the document against the dtd instance.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateDtdFinal>validateDtdFinal</a></td><td class=docright>
Does the final step for the dtds validation once all the subsets have been parsed.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateElement>validateElement</a></td><td class=docright>
Try to validate the subtree under an element.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateElementDecl>validateElementDecl</a></td><td class=docright>
Try to validate a single element definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateRoot>validateRoot</a></td><td class=docright>
Try to validate a the root element.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlValidCtxt_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#newValidCtxt>newValidCtxt</a></td><td class=docright>
Allocate a validation context structure.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateAttributeValue>validateAttributeValue</a></td><td class=docright>
Validate that the given attribute value match the proper production.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateNamesValue>validateNamesValue</a></td><td class=docright>
Validate that the given value match Names production.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateNameValue>validateNameValue</a></td><td class=docright>
Validate that the given value match Name production.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateNmtokensValue>validateNmtokensValue</a></td><td class=docright>
Validate that the given value match Nmtokens production.
</td></tr>
<tr><td class=docleft width=1%><a href=#validateNmtokenValue>validateNmtokenValue</a></td><td class=docright>
Validate that the given value match Nmtoken production.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=buildContentModel>
<tr><td class=doctop colspan=2>Method buildContentModel:Int(elem:TxmlDtdElement)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 in case of success, 0 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>(Re)Build the automata associated to the content model of the element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>elem</b> : an element declaration node</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the validation context structure.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDocument>
<tr><td class=doctop colspan=2>Method getDocument:TxmlDoc()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the document for this object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isFinishedDtd>
<tr><td class=doctop colspan=2>Method isFinishedDtd:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if finished validating the DTD.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isValid>
<tr><td class=doctop colspan=2>Method isValid:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the temporary validity check result state.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateAttributeDecl>
<tr><td class=doctop colspan=2>Method validateAttributeDecl:Int(doc:TxmlDoc, attr:TxmlDtdAttribute)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate a single attribute definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does the following checks as described by the XML-1.0 recommendation:<br>
[ VC: Attribute Default Legal ]<br>
[ VC: Enumeration ]<br>
[ VC: ID Attribute Default ]<br>
The ID/IDREF uniqueness and matching are done separately.
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
<li><b>attr</b> : an attribute definition</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateDocument>
<tr><td class=doctop colspan=2>Method validateDocument:Int(doc:TxmlDoc)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate the document instance.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateDocumentFinal>
<tr><td class=doctop colspan=2>Method validateDocumentFinal:Int(doc:TxmlDoc)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Does the final step for the document validation once all the incremental validation steps have been completed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does the following checks described by the XML Rec. Check all the IDREF/IDREFS
attributes definition for validity.
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateDtd>
<tr><td class=doctop colspan=2>Method validateDtd:Int(doc:TxmlDoc, dtd:TxmlDtd)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate the document against the dtd instance.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does check all the definitions in the DtD. Note the the internal subset
(if present) is de-coupled (i.e. not used), which could give problems if ID or IDREF is present.
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
<li><b>dtd</b> : a DTD instance</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateDtdFinal>
<tr><td class=doctop colspan=2>Method validateDtdFinal:Int(doc:TxmlDoc, dtd:TxmlDtd)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 if invalid and -1 if not well-formed.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Does the final step for the dtds validation once all the subsets have been parsed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does the following checks described by the XML Rec<br>
Check that ENTITY and ENTITIES type attributes default or possible values matches one of the
defined entities.<br>
Check that NOTATION type attributes default or possible values matches one of the defined notations.
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateElement>
<tr><td class=doctop colspan=2>Method validateElement:Int(doc:TxmlDoc, elem:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate the subtree under an element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
<li><b>elem</b> : an element instance</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateElementDecl>
<tr><td class=doctop colspan=2>Method validateElementDecl:Int(doc:TxmlDoc, elem:TxmlDtdElement)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate a single element definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does the following checks as described by the XML-1.0 recommendation:<br>
[ VC: One ID per Element Type ]<br>
[ VC: No Duplicate Types ]<br>
[ VC: Unique Element Type Declaration ]
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
<li><b>elem</b> : an element definition</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateRoot>
<tr><td class=doctop colspan=2>Method validateRoot:Int(doc:TxmlDoc)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Try to validate a the root element.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Basically it does the following check as described by the XML-1.0 recommendation:<br>
[ VC: Root Element Type ] it doesn't try to recurse or apply other check to the element
<p>Parameters:
<ul>
<li><b>doc</b> : a document instance</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newValidCtxt>
<tr><td class=doctop colspan=2>Function newValidCtxt:TxmlValidCtxt()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>Null if not, otherwise the new validation context structure.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Allocate a validation context structure.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateAttributeValue>
<tr><td class=doctop colspan=2>Function validateAttributeValue:Int(attributeType:Int, value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Validate that the given attribute value match the proper production.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>[ VC: ID ] Values of type ID must match the Name production....<br>
[ VC: IDREF ] Values of type IDREF must match the Name production, and values of type IDREFS must match Names ...<br>
[ VC: Entity Name ] Values of type ENTITY must match the Name production, values of type ENTITIES must match Names ...<br>
[ VC: Name Token ] Values of type NMTOKEN must match the Nmtoken production; values of type NMTOKENS must match Nmtokens.
<p>Parameters:
<ul>
<li><b>attributeType</b> : an attribute type (see below)</li>
<li><b>value</b> : an attribute value</li>
</ul>
</p>
<p>The following lists possible attribute types:</p>
<table>
<tr><th>Constant</th></tr>
<tr><td>XML_ATTRIBUTE_CDATA</td></tr>
<tr><td>XML_ATTRIBUTE_ID</td></tr>
<tr><td>XML_ATTRIBUTE_IDREF</td></tr>
<tr><td>XML_ATTRIBUTE_IDREFS</td></tr>
<tr><td>XML_ATTRIBUTE_ENTITY</td></tr>
<tr><td>XML_ATTRIBUTE_ENTITIES</td></tr>
<tr><td>XML_ATTRIBUTE_NMTOKEN</td></tr>
<tr><td>XML_ATTRIBUTE_NMTOKENS</td></tr>
<tr><td>XML_ATTRIBUTE_ENUMERATION</td></tr>
<tr><td>XML_ATTRIBUTE_NOTATION</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateNamesValue>
<tr><td class=doctop colspan=2>Function validateNamesValue:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Validate that the given value match Names production.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : a Names value</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateNameValue>
<tr><td class=doctop colspan=2>Function validateNameValue:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Validate that the given value match Name production.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : an Name value</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateNmtokensValue>
<tr><td class=doctop colspan=2>Function validateNmtokensValue:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Validate that the given value match Nmtokens production.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>[ VC: Name Token ]
<p>Parameters:
<ul>
<li><b>value</b> : an Nmtokens value</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=validateNmtokenValue>
<tr><td class=doctop colspan=2>Function validateNmtokenValue:Int(value:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>1 if valid or 0 otherwise.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Validate that the given value match Nmtoken production.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>[ VC: Name Token ]
<p>Parameters:
<ul>
<li><b>value</b> : an Nmtoken value</li>
</ul>
</p></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlXIncludeCtxt>
<tr><td class=doctop colspan=2>Type TxmlXIncludeCtxt</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML XInclude context.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXIncludeCtxt_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free the XInclude context.
</td></tr>
<tr><td class=docleft width=1%><a href=#processNode>processNode</a></td><td class=docright>
Implement the XInclude substitution for the given subtree reusing the informations and data coming from the given context.
</td></tr>
<tr><td class=docleft width=1%><a href=#setFlags>setFlags</a></td><td class=docright>
Set the flags used for further processing of XML resources.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXIncludeCtxt_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#newContext>newContext</a></td><td class=docright>
Creates a new XInclude context.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free the XInclude context.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=processNode>
<tr><td class=doctop colspan=2>Method processNode:Int(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 if no substitution were done, -1 if some processing failed or the number of substitutions done.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement the XInclude substitution for the given subtree reusing the informations and data coming from the given context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>node</b> : a node in an XML document</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=setFlags>
<tr><td class=doctop colspan=2>Method setFlags:Int(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>0 in case of success and -1 in case of error.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the flags used for further processing of XML resources.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>flags</b> : a set of xml Parser Options used for parsing XML includes. (see <a href=#fromFile>fromFile</a> for details on available options)</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=newContext>
<tr><td class=doctop colspan=2>Function newContext:TxmlXIncludeCtxt(doc:TxmlDoc)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The new context.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new XInclude context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>doc</b> : an XML Document</li>
</ul></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlXPathCompExpr>
<tr><td class=doctop colspan=2>Type TxmlXPathCompExpr</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A compiled XPath expression.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathCompExpr_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#eval>eval</a></td><td class=docright>
Evaluate the precompiled XPath expression in the given context.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up the allocated memory.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathCompExpr_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Compile>Compile</a></td><td class=docright>
Compile an XPath expression.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=eval>
<tr><td class=doctop colspan=2>Method eval:TxmlXPathObject(context:TxmlXPathContext)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlXPathObject resulting from the evaluation or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Evaluate the precompiled XPath expression in the given context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>context</b> : the XPath context</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up the allocated memory.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Compile>
<tr><td class=doctop colspan=2>Function Compile:TxmlXPathCompExpr(expr:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlXPathCompExpr resulting from the compilation or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Compile an XPath expression.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>expr</b> : the XPath expression</li>
</ul></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlXPathContext>
<tr><td class=doctop colspan=2>Type TxmlXPathContext</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML XPath Context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Expression evaluation occurs with respect to a context.<br>
The context consists of:
<ul>
<li> a node (the context node)</li>
<li> a node list (the context node list)</li>
<li> a set of variable bindings</li>
<li> a function library</li>
<li> the set of namespace declarations in scope for the expression</li>
</ul></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathContext_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#countDefinedTypes>countDefinedTypes</a></td><td class=docright>
Returns the number of defined types.
</td></tr>
<tr><td class=docleft width=1%><a href=#eval>eval</a></td><td class=docright>
Evaluate the XPath Location Path in the context.
</td></tr>
<tr><td class=docleft width=1%><a href=#evalExpression>evalExpression</a></td><td class=docright>
Evaluate the XPath expression in the context.
</td></tr>
<tr><td class=docleft width=1%><a href=#evalPredicate>evalPredicate</a></td><td class=docright>
Evaluate a predicate result for the current node.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up the TxmlXPathContext.
</td></tr>
<tr><td class=docleft width=1%><a href=#getContextSize>getContextSize</a></td><td class=docright>
Returns the context size.
</td></tr>
<tr><td class=docleft width=1%><a href=#getDocument>getDocument</a></td><td class=docright>
Return the TxmlDoc associated to this XPath context.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFunction>getFunction</a></td><td class=docright>
Returns the function name when calling a function.
</td></tr>
<tr><td class=docleft width=1%><a href=#getFunctionURI>getFunctionURI</a></td><td class=docright>
Returns the function URI when calling a function.
</td></tr>
<tr><td class=docleft width=1%><a href=#getHere>getHere</a></td><td class=docright>
Returns the XPointer for here.
</td></tr>
<tr><td class=docleft width=1%><a href=#getMaxTypes>getMaxTypes</a></td><td class=docright>
Returns the max number of types.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNode>GetNode</a></td><td class=docright>
Return the current TxmlNode associated with this XPath context.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetOrigin>GetOrigin</a></td><td class=docright>
Returns the XPointer for origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#getProximityPosition>getProximityPosition</a></td><td class=docright>
Returns the proximity position.
</td></tr>
<tr><td class=docleft width=1%><a href=#isXPointerContext>isXPointerContext</a></td><td class=docright>
Returns whether this is an XPointer context or not.
</td></tr>
<tr><td class=docleft width=1%><a href=#registerNamespace>registerNamespace</a></td><td class=docright>
Register a new namespace.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerEval>XPointerEval</a></td><td class=docright>
Evaluate the XPath Location Path in the context.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathContext_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewContext>XPointerNewContext</a></td><td class=docright>
Create a new XPointer context.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=countDefinedTypes>
<tr><td class=doctop colspan=2>Method countDefinedTypes:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the number of defined types.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=eval>
<tr><td class=doctop colspan=2>Method eval:TxmlXPathObject(text:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A TxmlXPathObject resulting from the evaluation or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Evaluate the XPath Location Path in the context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>text</b> : the XPath expression</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=evalExpression>
<tr><td class=doctop colspan=2>Method evalExpression:TxmlXPathObject(text:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>A TxmlXPathObject resulting from the evaluation or Null.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Evaluate the XPath expression in the context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>text</b> : the XPath expression</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=evalPredicate>
<tr><td class=doctop colspan=2>Method evalPredicate:Int(res:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Evaluate a predicate result for the current node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean.
If the result is a number, the result will be converted to true if the number is equal to the position of the
context node in the context node list (as returned by the position function) and will be converted to false
otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up the TxmlXPathContext.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getContextSize>
<tr><td class=doctop colspan=2>Method getContextSize:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the context size.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getDocument>
<tr><td class=doctop colspan=2>Method getDocument:TxmlDoc()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return the TxmlDoc associated to this XPath context.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFunction>
<tr><td class=doctop colspan=2>Method getFunction:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the function name when calling a function.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getFunctionURI>
<tr><td class=doctop colspan=2>Method getFunctionURI:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the function URI when calling a function.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getHere>
<tr><td class=doctop colspan=2>Method getHere:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the XPointer for here.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getMaxTypes>
<tr><td class=doctop colspan=2>Method getMaxTypes:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the max number of types.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNode>
<tr><td class=doctop colspan=2>Method GetNode:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return the current TxmlNode associated with this XPath context.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetOrigin>
<tr><td class=doctop colspan=2>Method GetOrigin:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the XPointer for origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getProximityPosition>
<tr><td class=doctop colspan=2>Method getProximityPosition:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the proximity position.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isXPointerContext>
<tr><td class=doctop colspan=2>Method isXPointerContext:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns whether this is an XPointer context or not.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=registerNamespace>
<tr><td class=doctop colspan=2>Method registerNamespace:Int(prefix:String, uri:String)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a new namespace.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If <b>uri</b> is Null it unregisters the namespace.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerEval>
<tr><td class=doctop colspan=2>Method XPointerEval:TxmlXPathObject(expr:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlXPathObject resulting from the evaluation or Null. The caller has to free the object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Evaluate the XPath Location Path in the context.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewContext>
<tr><td class=doctop colspan=2>Function XPointerNewContext:TxmlXPathContext(doc:TxmlDoc, here:TxmlNode, origin:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The TxmlXPathContext just allocated.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new XPointer context.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>doc</b> : the XML document</li>
<li><b>here</b> : the node that directly contains the XPointer being evaluated or Null</li>
<li><b>origin</b> : the element from which a user or program initiated traversal of the link, or Null</li>
</ul></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=TxmlXPathObject>
<tr><td class=doctop colspan=2>Type TxmlXPathObject</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An XML XPath Object.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathObject_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#castToBoolean>castToBoolean</a></td><td class=docright>
Converts the XPath object to its boolean value.
</td></tr>
<tr><td class=docleft width=1%><a href=#castToNumber>castToNumber</a></td><td class=docright>
Converts the XPath object to its number value.
</td></tr>
<tr><td class=docleft width=1%><a href=#castToString>castToString</a></td><td class=docright>
Converts the XPath object to its string value.
</td></tr>
<tr><td class=docleft width=1%><a href=#convertBoolean>convertBoolean</a></td><td class=docright>
Converts an existing object to its boolean() equivalent.
</td></tr>
<tr><td class=docleft width=1%><a href=#convertNumber>convertNumber</a></td><td class=docright>
Converts an existing object to its number() equivalent.
</td></tr>
<tr><td class=docleft width=1%><a href=#convertString>convertString</a></td><td class=docright>
Converts an existing object to its string() equivalent.
</td></tr>
<tr><td class=docleft width=1%><a href=#copy>copy</a></td><td class=docright>
Allocate a new copy of a given object.
</td></tr>
<tr><td class=docleft width=1%><a href=#free>free</a></td><td class=docright>
Free up the TxmlXPathObject.
</td></tr>
<tr><td class=docleft width=1%><a href=#getNodeSet>getNodeSet</a></td><td class=docright>
Returns the node set for the xpath.
</td></tr>
<tr><td class=docleft width=1%><a href=#getStringValue>getStringValue</a></td><td class=docright>
Returns the xpath object string value.
</td></tr>
<tr><td class=docleft width=1%><a href=#getType>getType</a></td><td class=docright>
The XPath object type.
</td></tr>
<tr><td class=docleft width=1%><a href=#nodeSetIsEmpty>nodeSetIsEmpty</a></td><td class=docright>
Whether the node set is empty or not.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerBuildNodeList>XPointerBuildNodeList</a></td><td class=docright>
Build a node list tree copy of the XPointer result.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerLocationSetCreate>XPointerLocationSetCreate</a></td><td class=docright>
Create a new TxmlLocationSet of type double and value of this XPathObject.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=TxmlXPathObject_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewCollapsedRange>XPointerNewCollapsedRange</a></td><td class=docright>
Create a new TxmlXPathObject of type range using a single node.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewLocationSetNodes>XPointerNewLocationSetNodes</a></td><td class=docright>
Create a new TxmlXPathObject of type LocationSet and initialize it with the single range made of the two nodes <b>startnode</b> and <b>endnode</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewLocationSetNodeSet>XPointerNewLocationSetNodeSet</a></td><td class=docright>
Create a new TxmlXPathObject of type LocationSet and initialize it with all the nodes from <b>nodeset</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRange>XPointerNewRange</a></td><td class=docright>
Create a new TxmlXPathObject of type range.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRangeNodeObject>XPointerNewRangeNodeObject</a></td><td class=docright>
Create a new TxmlXPathObject of type range from a node to an object.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRangeNodePoint>XPointerNewRangeNodePoint</a></td><td class=docright>
Create a new TxmlXPathObject of type range from a node to a point.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRangeNodes>XPointerNewRangeNodes</a></td><td class=docright>
Create a new TxmlXPathObject of type range using 2 nodes.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRangePointNode>XPointerNewRangePointNode</a></td><td class=docright>
Create a new TxmlXPathObject of type range from a point to a node.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerNewRangePoints>XPointerNewRangePoints</a></td><td class=docright>
Create a new xmlXPathObjectPtr of type range using 2 Points.
</td></tr>
<tr><td class=docleft width=1%><a href=#XPointerWrapLocationSet>XPointerWrapLocationSet</a></td><td class=docright>
Wrap the LocationSet <b>value</b> in a new TxmlXPathObject.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToBoolean>
<tr><td class=doctop colspan=2>Method castToBoolean:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The boolean value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the XPath object to its boolean value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToNumber>
<tr><td class=doctop colspan=2>Method castToNumber:Double()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the XPath object to its number value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=castToString>
<tr><td class=doctop colspan=2>Method castToString:String()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The string value.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts the XPath object to its string value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=convertBoolean>
<tr><td class=doctop colspan=2>Method convertBoolean:TxmlXPathObject()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new object, this one is freed.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts an existing object to its boolean() equivalent.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=convertNumber>
<tr><td class=doctop colspan=2>Method convertNumber:TxmlXPathObject()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new object, this one is freed.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts an existing object to its number() equivalent.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=convertString>
<tr><td class=doctop colspan=2>Method convertString:TxmlXPathObject()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the new object, this one is freed.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Converts an existing object to its string() equivalent.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=copy>
<tr><td class=doctop colspan=2>Method copy:TxmlXPathObject()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Allocate a new copy of a given object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=free>
<tr><td class=doctop colspan=2>Method free()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Free up the TxmlXPathObject.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getNodeSet>
<tr><td class=doctop colspan=2>Method getNodeSet:TxmlNodeSet()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the node set for the xpath.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getStringValue>
<tr><td class=doctop colspan=2>Method getStringValue:String()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the xpath object string value.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=getType>
<tr><td class=doctop colspan=2>Method getType:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The XPath object type.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The following lists possible XPath object types:<br>
<table>
<tr><th>Constant</th></tr>
<tr><td>XPATH_UNDEFINED</td></tr>
<tr><td>XPATH_NODESET</td></tr>
<tr><td>XPATH_BOOLEAN</td></tr>
<tr><td>XPATH_NUMBER</td></tr>
<tr><td>XPATH_STRING</td></tr>
<tr><td>XPATH_POINT</td></tr>
<tr><td>XPATH_RANGE</td></tr>
<tr><td>XPATH_LOCATIONSET</td></tr>
<tr><td>XPATH_USERS</td></tr>
<tr><td>XPATH_XSLT_TREE</td></tr>
</table></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=nodeSetIsEmpty>
<tr><td class=doctop colspan=2>Method nodeSetIsEmpty:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Whether the node set is empty or not.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerBuildNodeList>
<tr><td class=doctop colspan=2>Method XPointerBuildNodeList:TxmlNode()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>An node list or Null. The caller has to free the node tree.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Build a node list tree copy of the XPointer result.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This will drop Attributes and Namespace declarations.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerLocationSetCreate>
<tr><td class=doctop colspan=2>Method XPointerLocationSetCreate:TxmlLocationSet()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlLocationSet of type double and value of this XPathObject.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewCollapsedRange>
<tr><td class=doctop colspan=2>Function XPointerNewCollapsedRange:TxmlXPathObject(node:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range using a single node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>node</b> : the starting and ending node</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewLocationSetNodes>
<tr><td class=doctop colspan=2>Function XPointerNewLocationSetNodes:TxmlXPathObject(startnode:TxmlNode, endnode:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type LocationSet and initialize it with the single range made of the two nodes <b>startnode</b> and <b>endnode</b>.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startnode</b> : the start Node value</li>
<li><b>endnode</b> : the end Node value or Null</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewLocationSetNodeSet>
<tr><td class=doctop colspan=2>Function XPointerNewLocationSetNodeSet:TxmlXPathObject(nodeset:TxmlNodeSet)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type LocationSet and initialize it with all the nodes from <b>nodeset</b>.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>nodeset</b> : a node set</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRange>
<tr><td class=doctop colspan=2>Function XPointerNewRange:TxmlXPathObject(startnode:TxmlNode, startindex:Int, endnode:TxmlNode, endindex:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startnode</b> : the starting node</li>
<li><b>startindex</b> : the start index</li>
<li><b>endnode</b> : the ending node</li>
<li><b>endindex</b> : the ending index</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRangeNodeObject>
<tr><td class=doctop colspan=2>Function XPointerNewRangeNodeObject:TxmlXPathObject(startnode:TxmlNode, endobj:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range from a node to an object.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startnode</b> : the starting node</li>
<li><b>endobj</b> : the ending object</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRangeNodePoint>
<tr><td class=doctop colspan=2>Function XPointerNewRangeNodePoint:TxmlXPathObject(startnode:TxmlNode, endpoint:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range from a node to a point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startnode</b> : the starting node</li>
<li><b>endpoint</b> : the ending point</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRangeNodes>
<tr><td class=doctop colspan=2>Function XPointerNewRangeNodes:TxmlXPathObject(startnode:TxmlNode, endnode:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range using 2 nodes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startnode</b> : the starting node</li>
<li><b>endnode</b> : the ending node</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRangePointNode>
<tr><td class=doctop colspan=2>Function XPointerNewRangePointNode:TxmlXPathObject(startpoint:TxmlXPathObject, endnode:TxmlNode)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new TxmlXPathObject of type range from a point to a node.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startpoint</b> : the starting point</li>
<li><b>endnode</b> : the ending node</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerNewRangePoints>
<tr><td class=doctop colspan=2>Function XPointerNewRangePoints:TxmlXPathObject(startpoint:TxmlXPathObject, endpoint:TxmlXPathObject)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a new xmlXPathObjectPtr of type range using 2 Points.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>startpoint</b> : the starting point</li>
<li><b>endpoint</b> : the ending point</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=XPointerWrapLocationSet>
<tr><td class=doctop colspan=2>Function XPointerWrapLocationSet:TxmlXPathObject(value:TxmlLocationSet)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The newly created object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Wrap the LocationSet <b>value</b> in a new TxmlXPathObject.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>value</b> : the LocationSet value</li>
</ul></td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>1.13</td></tr>
<tr><th width=1%>License</th><td>MIT</td></tr>
<tr><th width=1%>Copyright</th><td>(libxml2) 1998-2007 Daniel Veillard</td></tr>
<tr><th width=1%>Copyright</th><td>(wrapper) 2006-2008 Bruce A Henderson</td></tr>
<tr><th width=1%>Modserver</th><td>BRL</td></tr>
<tr><th width=1%>History</th><td>1.13</td></tr>
<tr><th width=1%>History</th><td>Fixed getLineNumber() returning wrong type.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlDoc ToString() and ToStringFormat() methods.</td></tr>
<tr><th width=1%>History</th><td>setContent() now accepts empty string.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlDoc SetEncoding() and SetStandalone() methods.</td></tr>
<tr><th width=1%>History</th><td>1.12</td></tr>
<tr><th width=1%>History</th><td>Improved error handling/capture.</td></tr>
<tr><th width=1%>History</th><td>Fixed xmlGetLastError calling wrong api.</td></tr>
<tr><th width=1%>History</th><td>Added new xmlSetErrorFunction() function to allow capture of all errors.</td></tr>
<tr><th width=1%>History</th><td>More error information available via new TxmlError methods().</td></tr>
<tr><th width=1%>History</th><td>1.11</td></tr>
<tr><th width=1%>History</th><td>Added unlinkNode and freeNode methods to TxmlNode.</td></tr>
<tr><th width=1%>History</th><td>1.10</td></tr>
<tr><th width=1%>History</th><td>Updated to Libxml 2.6.27.</td></tr>
<tr><th width=1%>History</th><td>Fixed Null byte ptr handling on UTF8 conversion.</td></tr>
<tr><th width=1%>History</th><td>Fixed several memory issues.</td></tr>
<tr><th width=1%>History</th><td>1.09</td></tr>
<tr><th width=1%>History</th><td>Added automatic libxml UTF-to-Max and Max-To-UTF String conversion. Fixes non-ascii string issues.</td></tr>
<tr><th width=1%>History</th><td>Added getLineNumber method to TxmlBase.</td></tr>
<tr><th width=1%>History</th><td>1.08</td></tr>
<tr><th width=1%>History</th><td>Exposed some XPathContext properties.</td></tr>
<tr><th width=1%>History</th><td>Fixed TxmlBuffer getContent not returning anything.</td></tr>
<tr><th width=1%>History</th><td>API change - Renamed TxmlURI URIEscapeStr() to URIEscapeString().</td></tr>
<tr><th width=1%>History</th><td>Docs tidy up.</td></tr>
<tr><th width=1%>History</th><td>Many more examples.</td></tr>
<tr><th width=1%>History</th><td>1.07</td></tr>
<tr><th width=1%>History</th><td>Added TxmlNode getAttributeList method.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlAttribute getAttributeType, getNameSpace methods.</td></tr>
<tr><th width=1%>History</th><td>Fixed attribute getValue returning nothing.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlDoc getVersion, getEncoding, isStandalone methods.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlBase getParent method.</td></tr>
<tr><th width=1%>History</th><td>getFirstChild and getLastChild now accept types.</td></tr>
<tr><th width=1%>History</th><td>Added more document examples.</td></tr>
<tr><th width=1%>History</th><td>1.06</td></tr>
<tr><th width=1%>History</th><td>Split out extern/const to libxml_base.</td></tr>
<tr><th width=1%>History</th><td>Added more globals.</td></tr>
<tr><th width=1%>History</th><td>Added validation API.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlDtdAttribute, TxmlDtdElement, TxmlNotation, TxmlValidCtxt, TxmlElementContent, TxmlXPathCompExpr.</td></tr>
<tr><th width=1%>History</th><td>1.05</td></tr>
<tr><th width=1%>History</th><td>Fixed TxmlNodeSet.getNodeList.</td></tr>
<tr><th width=1%>History</th><td>API change - Added TxmlBase (for shared methods). Extended Node, Doc, Dtd, Attribute, Entity from it. Should be backwards compatible.</td></tr>
<tr><th width=1%>History</th><td>Implemented debug-time assertion checking.</td></tr>
<tr><th width=1%>History</th><td>Incbin support added for TxmlDoc and TxmlTextReader.</td></tr>
<tr><th width=1%>History</th><td>Added more XPath functionality.</td></tr>
<tr><th width=1%>History</th><td>Added libxml globals.</td></tr>
<tr><th width=1%>History</th><td>Added Entities API, XInclude API, XPointer API.</td></tr>
<tr><th width=1%>History</th><td>Added XML catalogs and SGML catalogs API.</td></tr>
<tr><th width=1%>History</th><td>Added TxmlURI, TxmlCatalog, TxmlEntity, TxmlIncludeCtxt, TxmlLocationSet.</td></tr>
<tr><th width=1%>History</th><td>1.04</td></tr>
<tr><th width=1%>History</th><td>Removed small memory leak.</td></tr>
<tr><th width=1%>History</th><td>Fixed typo - addProcessingInstruction(), and added some missing docs.</td></tr>
<tr><th width=1%>History</th><td>Added newNode() function for TxmlNode.</td></tr>
<tr><th width=1%>History</th><td>1.03</td></tr>
<tr><th width=1%>History</th><td>Added TxmlTextReader API.</td></tr>
<tr><th width=1%>History</th><td>Removed ansidecl.h use for linux - not always present.</td></tr>
<tr><th width=1%>History</th><td>1.02</td></tr>
<tr><th width=1%>History</th><td>Removed xmlmodule.c</td></tr>
<tr><th width=1%>History</th><td>Changed references of xmllasterror to xmllasterror1 for Mac compile.</td></tr>
<tr><th width=1%>History</th><td>Disabled thread support and made static build - removed lots of warnings.</td></tr>
<tr><th width=1%>History</th><td>1.01</td></tr>
<tr><th width=1%>History</th><td>Added Linux and Mac support. Still some Mac issues to resolve.</td></tr>
<tr><th width=1%>History</th><td>1.00 Initial Release (Libxml 2.6.23)</td></tr>
</body></html>
